---
title: "Vibe Coding: AI编程总结"
date: 2025-08-19T16:24:41+08:00
draft: false
categories: 'AI'
---

## 缘起

我接触 AI 编程挺早了，体验过从早期蛮荒交互形式：在聊天框里问答然后复制结果到编辑器，到最近植入到 IDE 内的， 以及 更加流行的 CLI 形式的交互演进。多少算是见证了 AI 编程的演进。

AI 编程的称呼也很多，有的叫 AI Coding，有的叫 AI Pair Programming，还有的叫 AI Copilot，甚至有的叫 AI Vibe Coding。我更喜欢 Pair Programming 这个说法，因为它强调了 AI 和人类的协作关系。

作为一个喜欢白嫖的用户，也会为顶部产品付费，最多的是 Cursor。因为真的被他们的效果吸引了，没有他就降低了很多效率。先列觉下我用过的 AI 编程工具：
1. 插件：Github Copilot / 通义灵码 / Cline / Bito / Codeium（Windsurf 早期形态）/ Augment
2. Vscode 系列：Cursor / WindSurf / Kiro / Trae
2. CLI 系列：Claude Code / Cursor CLI / Gemini CLI

目前使用最多的是 Cursor 和 Claude Code。

使用数据：工作中几乎 90% 的代码是 AI 生成的。

下面总结下我对 AI 编程的体验和感受，Lets go

## 交互形式
蛮荒期的交互很简单： 在一个 Chat 框里，一顿问答，然后把输出内容，就是把 AI 当作搜索引擎用了。这里几乎没有什么上下文，仅靠系统提示词给一些约束

IDE 插件的形式：早期 Github 的 Copilot。这种能在编辑器光标的地方直接生成并插入，然后使用 Tab 来接受（后期 Cursor 把这个体验打到极致：能预测下一个光标位置，这也是cursor的 slogan: Tab，Tab，Tab，done），也能有个侧边栏出现 Chat 框，只是这里的 Chat 框里仅包含问答

AI IDE： Cursor WindSurf，及后来的 kiro， Codebuddy 等等。能更方便的操作编辑器：获取更多的上下文，更有效的上下文，回填，插入修改等。让体验更丝滑。由于能拿到更好的上下文，效果也更好。大家一致认可，也成功帮助这些公司拿到恐怖的融资。

AI CLI： 这种形式的交互，主要是通过命令行来进行交互。典型代表有 Claude Code 和 Cursor CLI， Gemini cli，等其他 Fork 开源产生的。特点是比较轻量，在一个终端里随意就能使用，但是少了编辑器的可视化操作，多少对于非专业工程师来说不太习惯

总结来看 AI 编程的交互上从两个方面进行的演进：1. 更好的收集代码上下文 2. 更好编辑效果，随时问答，随时采纳，approvel等。
## AI 编程的效果
影响 AI 效果的因素很多，我给的排行是：上下文提供能力 > 模型本身能力 > 工作模式 > 个人提示词能力。这也是各个厂商竞争激烈的核心。我们展开来说

### 上下文提供能力。

这个也是跟上一节有很大关系，交互上会影响上下文的收集提取提供等，让AI帮我们写局部功能，几乎都没什么问题。但是大的项目，跨文件比较多，依赖线比较复杂的时候，怎么能让AI理解下来呢？

CodeBase：这个有点类似工程里的 RAG 的概念，把整个项目当作一个知识库，做 Embedding，甚至做一些预先总结梳理，当用户提一个需求的时候，可以基于整个代码仓库来分析。

临时文件添加：现在 IDE 里都能临时指定一些文件作为上下文。

IDE：主要要求用户添加的一些上下文，指定到仓库某个路径下，一般是 Markdown 格式的描述。

### 模型本身能力
注意虽然我把他排行在第二位，但这个是能拉开差距的关键，而且上下文提供能力大家都能做的七七八八，不是难点，拉不开差距。

模型能力就不一样了，这个不是谁想做好就做好的，而且成本也巨高，能大幅拉开差距。时下最好的依然是 Claude 4 系列。其次是 Gemini Pro， Gpt5。国内的模型也有一些不错的表现，像是 Qwen-coder-plus，Kimi-K2。

但是呢做模型的就那几家顶级大厂，其他的只能在模型上做一些小的优化，或者在模型上做一些小的微调。这里不多展开。

### 工作模式
1. 单轮交互模式。这个是最简单的模式，用户提一个需求，AI 直接给出结果。这个模式下，AI 的能力要求就比较高了，尤其是上下文理解能力和代码生成能力。
2. 讨论方案，以文档形式展示出来，允许用户修改，然后生成 Task 列表，有些称为 Todo List，然后基于这个 Task 列表去逐条执行。直到完成，最后给出一个总结，交付用户采纳或者驳回修改之类
3. Sub Agent 模式。我理解这里跟时下多Agent的概念类似。但是多 Agent 可以节省总体 token，上下文容量等。
4. Rules-based 模式。这个模式下，AI 会根据一些预定义的规则来生成代码，比如代码风格，命名规范，测试覆盖率等等。这个模式下，AI 的能力要求相对较低，但是需要用户提供一些规则。

工作模式还有很多未知，探索空间也很大，再结合上下文提供能里的探索可以说是AI编辑器的核心了，这块的能力也很大程度上决定了 AI 编程的效果，也是各家厂商竞争的一个重要方向，竞争之激烈可谓到决生死的地步了。

当然针对不同类型，不同规模的任务需要使用不同的


## 工具体验
工具体验以及我总结的最佳实践：

[详细看这里](/posts/ai-cursor-claudecode)

## 作为一个 AI 应用开发者 如何看这些产品
作为一个 AI 应用开发者，我觉得这些产品给了我很多启发和思考。目前所有 AI 应用基本都是围绕上下文工程做来做功能的。这在之前被称为 Prompt Engineering。现在更广义的叫做 Context Engineering。

Agent 产品核心理念没有变: 利用 LLM 作为「大脑」，加上周边的「工具」(我认为 mcp 也是这个思路，只是在交互上做了些标准化的内容)，以及状态管理引擎来驱动完成一个 自然语言描述的任务。

当下由于模型能力及各种条件下，或许有程序员本身更容易接触 AI，使得编程工具是最先最成熟的 AI Agent 落地场景

## 实际中常用 AI 做什么？
1. 修 Bug
2. 帮我画架构图，理解项目
3. 帮我完成开发任务，甚至整个项目的生成
4. 生成文档，接口文档，测试文档，类型定义
5. 写作，写文章。因为文章也是语言，也是需要编辑，润色，改写等

总体来看能当作一个任务执行者，帮做些烦杂枯燥的任务。

## 杠杆 杠杆 杠杆
编程 AI 这个杠杆该如何利用呢？

我在社区关注的一些概念：「一人公司」，「一人一年开发 30 个应用」等。暂且不谈我对这些概念的看法，我觉得这些概念的核心是利用 AI 这个杠杆，来提升个人的生产力。

落地路径，我觉得就是
1. 总结好自己的一套提示词库，面对各种场景的
2. 自动化脚本：自己写一些跑一些任务，让机器不停歇的帮我们干活

在应用开发上 重要的是多学习下架构文档的编写，当写完架构，再让 AI 补充详细设计，然后拿着详细设计丢给 Cursor， Kiro，Claude Code 等等，生成代码，然后再让 AI 帮我写测试用例，文档等。

因为有了 AI 这个杠杆来让实现变得简单起来，不再是那个缺个程序员的时代了，「需求的挖掘和验证」变得更加重要了，这也是中后期 AI 时代的核心竞争力了。

> 路漫漫其修远兮，吾将上下而求索
