<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>技术 on 钟灵毓秀</title>
    <link>https://tomorrowthief.github.io/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on 钟灵毓秀</description>
    <image>
      <url>https://tomorrowthief.github.io/cover.png</url>
      <link>https://tomorrowthief.github.io/cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 12 Sep 2025 15:47:00 +0800</lastBuildDate><atom:link href="https://tomorrowthief.github.io/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>通用 Agent调研</title>
      <link>https://tomorrowthief.github.io/posts/ai-agent/</link>
      <pubDate>Fri, 12 Sep 2025 15:47:00 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-agent/</guid>
      <description>&lt;p&gt;近日接到通用智能体开发任务。类似 Manus，服务于公司内部一些场景，预计包含 PPT 制作，DeepResearch，小型开发任务等。&lt;/p&gt;
&lt;p&gt;这里梳理下当前业界里的 通用 Agent。包含其产品特点，大致实现思路等。&lt;/p&gt;
&lt;h2 id=&#34;teamoteam&#34;&gt;&lt;a href=&#34;https://teamoteam.com/index&#34;&gt;teamoteam&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一家国内的 Agent，创始人早期在百度的某AI算法团队，后离职专做这个 Agent。
主要应用场景是：写作，调研。属于一个典型的多 Agent 架构的应用。&lt;/p&gt;
&lt;img width=&#34;1689&#34; height=&#34;845&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/6bf9cec1-3341-476f-b14c-bb902d29612d&#34; /&gt;
&lt;h2 id=&#34;manus&#34;&gt;&lt;a href=&#34;https://manus.im/app&#34;&gt;manus&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;国内网红 Agent 公司，早期拼接炒作火了一把，并且把体验码炒到数万一个。也拿到了一些融资。&lt;/p&gt;
&lt;p&gt;核心功能：&lt;/p&gt;
&lt;h2 id=&#34;核心技术&#34;&gt;核心技术&lt;/h2&gt;
&lt;h3 id=&#34;多-agent-架构&#34;&gt;多 Agent 架构&lt;/h3&gt;
&lt;h3 id=&#34;工具&#34;&gt;工具&lt;/h3&gt;
&lt;h3 id=&#34;调优&#34;&gt;调优&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>AI 应用技术</title>
      <link>https://tomorrowthief.github.io/posts/ai-tec/</link>
      <pubDate>Fri, 08 Aug 2025 18:17:41 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-tec/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;梳理下自己在 AI 产品开发中用到的一些工程技术，只会做工程了属于是，算法方面的东西基本上不懂。&lt;/p&gt;
&lt;p&gt;列下我做过的东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Code Review Agent&lt;/li&gt;
&lt;li&gt;Long term memory&lt;/li&gt;
&lt;li&gt;Dify 二开&lt;/li&gt;
&lt;li&gt;Rag 流程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;语言技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Nodejs&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agent 框架：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Langchain&lt;/li&gt;
&lt;li&gt;React Agent&lt;/li&gt;
&lt;li&gt;Function calling&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结下来基本上都是常规的 web 技术栈，只是多了一个 与 LLM 交互的环节。本文从工程与算法两层来总结梳理自己了解到的东西&lt;/p&gt;
&lt;h2 id=&#34;关系&#34;&gt;关系&lt;/h2&gt;
&lt;p&gt;工程与模型的关系，有点像是算法里的复杂度控制：空间换时间，时间换空间，性能换效率，效率换性能&lt;/p&gt;
&lt;p&gt;工程是重点不是难点，模型是难点不是重点毕竟能搞模型的就那么几家公司&lt;/p&gt;
&lt;h2 id=&#34;工程&#34;&gt;工程&lt;/h2&gt;
&lt;h3 id=&#34;起步与-llm-交互&#34;&gt;起步：与 LLM 交互&lt;/h3&gt;
&lt;p&gt;唯有提示词，就像圣经里能唯一与上帝交流传话的那个家伙。&lt;/p&gt;
&lt;p&gt;形式上有 stream blocking。&lt;/p&gt;
&lt;p&gt;通信载体几乎是基于：Http，无非是协议上多了一些 sse streamable 返回等。&lt;/p&gt;
&lt;h3 id=&#34;agent-范式&#34;&gt;Agent 范式&lt;/h3&gt;
&lt;p&gt;React 一直是比较经典的范式，很多其他模式也是基于这个演化的&lt;/p&gt;
&lt;p&gt;早期 React 范式的实现，全部依赖提示词，比如 Function 描述，工具返回内容的格式，Stop 策略等一股脑的都会拼接到提示词上，然后返回内容的解析也会根据一些约定标记等做信息提取&lt;/p&gt;
&lt;p&gt;中期这些内容被 大模型公司给 Native 了，做到模型内部了： function call api 规范&lt;/p&gt;
&lt;p&gt;当前是被 MCP 协议规范了，当然底层还是基于 funciton call 的能力包装的标准协议&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AI 产品思考</title>
      <link>https://tomorrowthief.github.io/posts/ai-products/</link>
      <pubDate>Fri, 08 Aug 2025 18:15:41 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-products/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;我是 AI应用开发者，开发过 AI Agent，Agent 搭建平台，也是 AI 产品的使用者。本文将分享我对 AI 产品的思考。主要是AI产品思路，列举一些好用的 AI 产品，和一些 AI 产品的使用技巧。&lt;/p&gt;
&lt;h2 id=&#34;ai-产品核心之核心&#34;&gt;AI 产品核心之核心&lt;/h2&gt;
&lt;p&gt;毋庸置疑核心是模型：LLM，Difusion Model，CV 模型等。与模型唯一通信载体是 Prompt，请记住这个唯一，非常重要，基本上功能都是围绕这个来做的。所以早期的AI产品都是称为 Prompt 产品，开发者是 prompt 工程师。&lt;/p&gt;
&lt;p&gt;而 Prompt 也有种类繁多的范式，不同场景不同目的使用不同的 Prompt。Prompt 设计的好坏直接影响 AI 产品的效果，这里暂且不表。&lt;/p&gt;
&lt;h2 id=&#34;agent-与-workflow&#34;&gt;Agent 与 Workflow&lt;/h2&gt;
&lt;h2 id=&#34;多-agent-模式与虚拟团队&#34;&gt;多 Agent 模式与虚拟团队&lt;/h2&gt;
&lt;h2 id=&#34;1人公司&#34;&gt;1人公司&lt;/h2&gt;
&lt;h2 id=&#34;好用的-ai-产品&#34;&gt;好用的 AI 产品&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>Devops概念梳理</title>
      <link>https://tomorrowthief.github.io/posts/devops/</link>
      <pubDate>Mon, 30 Dec 2024 13:50:01 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/devops/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Devops 从18年左右发展至今已经非常的成熟。可以作为一个独立职业，因为里面有很多细节。作为互联网软件开发者，我从开发的视角梳理下一些应知应会的框架，主要达到一个能使用，能了解架构，出了问题大概知道在哪个环节。具体细节暂时不追求。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;Docker，是一种容器化的概念，属于虚拟化技术的一种形式。以颗粒度更小的方式，隔离性也更好的方式完成宿主机的资源榨取。他与虚拟机的核心区别是&lt;/p&gt;
&lt;p&gt;Docker与虚拟机的核心区别主要在于以下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;架构层级&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机（Virtual Machine, VM）&lt;/strong&gt;：虚拟机在宿主操作系统之上运行一个完整的客户操作系统。它使用Hypervisor（如VMware、KVM、Hyper-V等）来虚拟化硬件资源，每个虚拟机都有自己的内核、操作系统和应用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：Docker容器在宿主操作系统之上运行，但它们与宿主共享相同的操作系统内核。容器是通过容器引擎（如Docker）来管理和隔离的。每个容器包含应用程序及其所有依赖项，但不包含完整的操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源利用效率&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：由于每个虚拟机都需要一个完整的操作系统，因此启动和运行时会消耗更多的内存和CPU资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：由于所有容器共享宿主操作系统的内核，启动时间更快，资源开销也更小。这使得容器更加轻量级，可以在同样的硬件上运行更多实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动时间&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：由于需要启动一个完整的操作系统，虚拟机通常需要数分钟时间才能完全启动并准备好使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：因为没有完整的OS启动过程，Docker容器通常可以在几秒钟内完成启动。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;隔离性与安全性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：提供了强隔离，因为每个VM运行在完全独立的环境中，包括独立的内核。因此，安全性较高。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：虽然提供了进程级别的隔离，但仍共享宿主OS内核，因此理论上存在一些安全风险。不过，通过适当配置和使用工具（如SELinux、AppArmor等），可以增强安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存储与持久化数据管理方式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：通常使用虚拟磁盘文件来存储数据，这些文件可以独立于其他VM进行管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：使用卷（volumes）和绑定挂载（bind mounts）来持久化数据，这些可以被多个容器共享或独立管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总而言之，Docker作为一种轻量级、便捷、高效且快速部署的方法，在云原生应用开发中得到了广泛应用。而虚拟机则仍然适用于需要强隔离、安全要求高以及需要运行不同类型操作系统等场景。&lt;/p&gt;
&lt;p&gt;Docker的核心原理是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker的核心原理是利用操作系统级的虚拟化技术（即容器化技术）来创建、部署和运行应用程序。具体来说，Docker 的核心原理包括以下几个方面：&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Namespace（命名空间）隔离&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker 使用 Linux 内核的命名空间（Namespace）功能来实现进程隔离。这些命名空间包括 UTS（主机和域名）、IPC（进程间通信）、PID（进程 ID）、Network（网络）、Mount（文件系统挂载点）等。&lt;/li&gt;
&lt;li&gt;每个容器都有独立的命名空间，因此它们之间不会互相干扰，提供了类似虚拟机的隔离效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cgroups（控制组）资源控制&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cgroups 是 Linux 内核提供的一种机制，用于限制、记录和隔离单个进程组的资源使用情况。Docker 使用 Cgroups 来限制容器可以使用的 CPU、内存、磁盘 I/O 等资源。&lt;/li&gt;
&lt;li&gt;通过这种方式，Docker 能够确保每个容器在资源分配上互不干扰，并且可以避免某个容器滥用系统资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Union File System（联合文件系统）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker 使用联合文件系统，如 AUFS、OverlayFS 等，来实现镜像和容器的分层存储。每个 Docker 镜像由多层组成，每一层都是只读的，当需要对镜像进行修改时，会在顶层添加一个可写层。&lt;/li&gt;
&lt;li&gt;这种分层设计不仅提高了存储效率，还使得镜像可以快速构建和共享。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Container Image（容器镜像）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器镜像是一个包含应用程序及其所有依赖项的只读模板。Docker 容器是从这些镜像创建出来的一种运行实例。&lt;/li&gt;
&lt;li&gt;镜像可以通过 Dockerfile 定义，并且支持版本管理，这使得应用程序环境变得可移植且易于复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Container Runtime&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LLM 长记忆工具总结</title>
      <link>https://tomorrowthief.github.io/posts/ai-longterm-memory/</link>
      <pubDate>Sat, 19 Oct 2024 11:48:00 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-longterm-memory/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;p&gt;近期工作中做了 LLM 长记忆功能，对此中的思路，技术做下总结。顺便为了练习自己的系统设计能力，这里按照系统设计的方式来整理&lt;/p&gt;
&lt;h2 id=&#34;什么是长记忆&#34;&gt;什么是长记忆&lt;/h2&gt;
&lt;p&gt;简单来说就是让大模型具备记忆功能，记住某个人。产品形态上可以是个人助手。不同于某次会话上下文记忆，长记忆具备的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跟随个人的：我们目前常见的短期记忆只是跟随某次会话&lt;/li&gt;
&lt;li&gt;时间长：1年，5年，10年，……，终生&lt;/li&gt;
&lt;li&gt;个人信息相关的：比如个人爱好，心情变化，健康，工作，生活等这些属于个人记忆。客观信息事实信息比如：美国在北美洲，地球是圆的等这些不需要作为记忆信息。&lt;/li&gt;
&lt;li&gt;多种类型的：如上条有不同类型的记忆，不同类型的记忆里处理方式有很大差异，比如：日程相关的需要处理时间，绝对时间的转换，个人爱好相关的，比较简单，直接用类似图谱的三元组信息即可，办公工作内容型的记忆类似。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;功能点及非功能点梳理&#34;&gt;功能点及非功能点梳理&lt;/h2&gt;
&lt;p&gt;总体其实为了实现个人助手的产品功能。这个助手在产品形态上是一个普通对话机器人，系统的具备的功能及非功能点需求大致如下：&lt;/p&gt;
&lt;h3 id=&#34;功能点&#34;&gt;功能点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;登录，因为是私人助手嘛，得知道用户是谁。&lt;/li&gt;
&lt;li&gt;对话：这个不用说了，是助手的主题功能&lt;/li&gt;
&lt;li&gt;配置功能，因为记忆有很多种类型，在助手里最好有配置，比如我想主要是工作，那日程安排比较重要，生活。如果多有记忆都要配置，那就是一个超级个人助手&lt;/li&gt;
&lt;li&gt;记忆生产：根据配置信息，做不同类型的记忆提取存储&lt;/li&gt;
&lt;li&gt;记忆消费：是指根据记忆：做下健康管理，饮食管理，工作学习计划，日程计划，等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;非功能点&#34;&gt;非功能点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;短期能同时处理 1w+ 人数的并发，长期的话人数可能扩充到 10W+，甚至更多。每天可能有 50W 的请求&lt;/li&gt;
&lt;li&gt;响应时间：在记忆消费时能做到 3s - 5s 内有响应，3s-30s 内响应完成。&lt;/li&gt;
&lt;li&gt;数据规模，根据每个人的配置，记忆长短不同，数据规模有不同要求&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;p&gt;工作流程图&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://tomorrowthief.github.io/long-term-memory.png&#34; alt=&#34;Alt text&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;如图所示。总体为一个 RAG 流程，其中核心是记忆引擎的部分。由于rag流程基础的东西，在社区里做的比较多，也比较简单，不做过多强调。核心强调记忆引擎的东西。&lt;/p&gt;
&lt;h2 id=&#34;记忆引擎&#34;&gt;记忆引擎&lt;/h2&gt;
&lt;p&gt;记忆引擎里完成的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记忆生产
根据配置信息生产一些垂类记忆&lt;/li&gt;
&lt;li&gt;记忆存储
把记忆抽出来后&lt;/li&gt;
&lt;li&gt;记忆消费
根据用户的问题，召回相关的记忆，并做简单推理规划&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;记忆生产&#34;&gt;记忆生产&lt;/h3&gt;
&lt;p&gt;这里输入是会话信息，需要做的是从会话信息里提取记忆实体。主要涉及到自然语言处理的部分。
知识图谱，我们使用知识图谱来完成记忆的载体。&lt;/p&gt;
&lt;p&gt;知识图谱的实体抽取，以及图数据库语法都是用额外的大模型来推理完成&lt;/p&gt;
&lt;h4 id=&#34;提示词设计&#34;&gt;提示词设计&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 信息抽取
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;sb&#34;&gt;`
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        你是一个信息提取专家
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        用户的输入如下：{query}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        实体信息：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;    `&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 记忆更新
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;sb&#34;&gt;`
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        你是一个图数据专家，请生成neo4j的sql语句
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        历史记忆如下：{memories}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        新的记忆如下：{memory}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        sql:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;    `&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里只给出部分，因为其他一些垂类的内容。其他还有很多，也算是核心。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>后端开发经验-阶段性总结思考</title>
      <link>https://tomorrowthief.github.io/posts/ai-backend-dev/</link>
      <pubDate>Sun, 22 Sep 2024 10:48:00 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-backend-dev/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;p&gt;做了大半年左右的后端开发后，总结下相关感受。&lt;/p&gt;
&lt;p&gt;技术栈：Python/Nodejs + React&lt;/p&gt;
&lt;p&gt;行业背景：LLM 应用， RAG， Agent&lt;/p&gt;
&lt;h2 id=&#34;后端开发思路&#34;&gt;后端开发思路&lt;/h2&gt;
&lt;p&gt;后端关注面更广范，几乎要关注整个应用软件运行所需所有的环节： 运维，应用，业务，服务，UI 等。&lt;/p&gt;
&lt;p&gt;其中核心工作流在于：充分理解需求，转换业务需求到系统的功能性设计及非功能指标设计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能设计上主要关注：数据结构，类包，业务模块，工作流等&lt;/li&gt;
&lt;li&gt;非功能性关注：性能，并发，安全，稳定等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;玩的是数据&#34;&gt;玩的是数据&lt;/h2&gt;
&lt;p&gt;数据算是核心中的核心了。所有的业务基础都是按照这个来的&lt;/p&gt;
&lt;h3 id=&#34;关系型业务&#34;&gt;关系型业务&lt;/h3&gt;
&lt;p&gt;mysql 或者 pg，选一个吧，这里我还没遇到两者特别大的差异的地方，因为我的业务场景里没那么复杂&lt;/p&gt;
&lt;p&gt;这里主要考虑：表结构设计，索引设计。&lt;/p&gt;
&lt;p&gt;如果到一定规模考虑 分区，分表，分库&lt;/p&gt;
&lt;p&gt;实际业务中大多需要找一个 ORM 库来完成在应用里方便的操作。&lt;/p&gt;
&lt;p&gt;如果有 Redis 或者其他异步复杂的事务处理，需要进一步考虑数据一致性。&lt;/p&gt;
&lt;h3 id=&#34;非关系&#34;&gt;非关系&lt;/h3&gt;
&lt;p&gt;Redis，Es，Mongodb，图数据库&lt;/p&gt;
&lt;p&gt;日志相关的一般存放到 mongodb 或者es，由于他们在倒排索引的效果做的比较好，方便快速全文索引，海量存储。&lt;/p&gt;
&lt;p&gt;Redis：内存数据库，来缓解在 mysql里不经常变动，又频繁查询的操作压力。当然他也可以做一些简单的消息中间件等&lt;/p&gt;
&lt;p&gt;图数据库&lt;/p&gt;
&lt;p&gt;在一些场景里需要做知识图谱，做关系，图数据库特别适合。这里核心是实体关系等三元组信息抽取，已有知识更新。得益于大模型这个第二大脑的配合，可以通过提示词让LLM帮我们去做实体抽取，三元组信息变得简单很多&lt;/p&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;这块也是一个非常大的技术体系，往深走的话需要专题讨论。&lt;/p&gt;
&lt;p&gt;我这边是入门不久，着重看了 Mysql 执行引擎的内容，B+ 索引的来由。练习了常用 SQL 语法（leetcode 50高频sql）&lt;/p&gt;
&lt;p&gt;由于之前了解过大数据基础知识，所以对于我前端出身学习这块，难度不大。&lt;/p&gt;
&lt;h2 id=&#34;一些中间件&#34;&gt;一些中间件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;消息中间件
几乎是必须的，做异步，服务结构等&lt;/li&gt;
&lt;li&gt;任务队列
做性能，并发等&lt;/li&gt;
&lt;li&gt;日志，错误处理等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;微服务体系&#34;&gt;微服务体系&lt;/h2&gt;
&lt;p&gt;很多公司其他基础模块都是基于微服务的方式提供的。系统扩充到一定程度肯定少不了微服务架构的梳理&lt;/p&gt;
&lt;p&gt;得益于 Service Mesh 这种微服务2.0架构。做上层应用变得异常简单了。日志，监控，服务注册调用 等都在 SideCar里&lt;/p&gt;
&lt;p&gt;我之前有过 Nodejs 接入微服务体系的经验，所以这块难度也不是特比大&lt;/p&gt;
&lt;h2 id=&#34;计算机基础&#34;&gt;计算机基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算机组成：cpu，gpu，硬盘，内存&lt;/li&gt;
&lt;li&gt;操作系统：进程线程协程等，资源管理，IO管理：网络/文件&lt;/li&gt;
&lt;li&gt;编译：前端：分词，语法分析，语法树，后端：机器平台生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式-时间空间互换&#34;&gt;分布式-时间空间互换&lt;/h2&gt;
&lt;p&gt;这里我觉得是计算机性能上一个很重要的思路，在优先的单机资源下实现高复杂度计算的模式。大数据的基石 Hadoop也是这个核心思想。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 学习总结</title>
      <link>https://tomorrowthief.github.io/posts/ai-python/</link>
      <pubDate>Sat, 22 Jun 2024 10:47:41 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-python/</guid>
      <description>&lt;h2 id=&#34;为什么要学-python&#34;&gt;为什么要学 Python&lt;/h2&gt;
&lt;p&gt;最近开始接触 Ai 相关的东西。主要是应用层的内容，比如 RAG Agent 等。此类应用特点：无需太多安全性能，偏向于工具，这块技术发展变化比较迅速，大模型日新月异，应用层技术也跟随变化较多。&lt;/p&gt;
&lt;p&gt;根据此特点选择脚本类型语言作为应用层开发语言。待选语言有 &lt;code&gt;Nodejs&lt;/code&gt; &lt;code&gt;python&lt;/code&gt;。 个人虽熟悉 Nodejs，但鉴于 Python 生态较好 性能较好等，最后决定 Python。&lt;/p&gt;
&lt;h2 id=&#34;python-综述&#34;&gt;Python 综述&lt;/h2&gt;
&lt;p&gt;Python 第一版本发布于 2000年，目前在 Tiobe 排行榜里人数排名第一，社区热度也升为第一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定位：高级语言，通用能力编程语言&lt;/li&gt;
&lt;li&gt;特性：动态语言，基于解释器，gc 等&lt;/li&gt;
&lt;li&gt;范式：函数编程，面向对象，面向过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要在 数据处理，计算，Web等发挥作用，AI 领域使用很多， Web 开发也有很多场景&lt;/p&gt;
&lt;p&gt;运行模式支持 多进程，多线程，协程&lt;/p&gt;
&lt;h2 id=&#34;执行流程&#34;&gt;执行流程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这一章直接问了 gpt，下面都是 ai 的回答&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在Python中，程序的执行流程通常是按照以下步骤进行的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;解释器读取源代码：Python解释器会逐行读取源代码文件，并将其转换为字节码形式，这是一种中间表示形式，可以被Python虚拟机执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;词法分析和语法分析：在这个阶段，Python解释器会将源代码分解成单词（Token）并构建语法树。这个过程包括词法分析（将源代码分解为Token）和语法分析（根据语法规则构建语法树）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译字节码：Python解释器将语法树转换为字节码。字节码是一种中间形式，类似于机器码，但是不是针对特定的硬件架构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行字节码：Python虚拟机执行字节码指令。这些指令会被逐条执行，从而实现程序的逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态类型检查：Python是一种动态类型语言，因此在运行时会进行类型检查。如果类型不匹配，会引发类型错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垃圾回收：Python具有自动内存管理机制，包括垃圾回收。垃圾回收器会定期检查不再使用的内存对象，并释放它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常处理：在程序执行过程中，如果发生异常，Python会查找合适的异常处理程序。如果找不到合适的处理程序，程序会中止并打印错误信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序结束：当程序执行完所有的代码或遇到显式的退出语句（如return或sys.exit()）时，程序结束执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;p&gt;跟我熟悉的 JS 差别很大，总体感受很灵活。基础的比如：变量 循环，函数的定义参数。可以直接看&lt;a href=&#34;https://docs.python.org/zh-cn/3/reference/index.html&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人感觉 1-2 周左右时间，即可上手基础开发。&lt;/p&gt;
&lt;p&gt;这里只提下我印象比较深刻的函数部分：
通过 def 定义，通过缩进写函数体，当然也可以添加类型系统，比如入参数类型，返回类型。基础demo如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数参数可以用 &lt;code&gt;*&lt;/code&gt; &lt;code&gt;*key_yars&lt;/code&gt; 来动态接收&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
