<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>架构 on 钟灵毓秀</title>
    <link>https://tomorrowthief.vercel.app/categories/%E6%9E%B6%E6%9E%84/</link>
    <description>Recent content in 架构 on 钟灵毓秀</description>
    <image>
      <url>https://tomorrowthief.vercel.app/cover.png</url>
      <link>https://tomorrowthief.vercel.app/cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 11 May 2022 10:38:36 +0800</lastBuildDate><atom:link href="https://tomorrowthief.vercel.app/categories/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>扩展性设计</title>
      <link>https://tomorrowthief.vercel.app/posts/extend-design/</link>
      <pubDate>Wed, 11 May 2022 10:38:36 +0800</pubDate>
      
      <guid>https://tomorrowthief.vercel.app/posts/extend-design/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前在公司内部做过「扩展性设计」的分享。后面重新整理形成博客形式记录自己的学习。&lt;/p&gt;
&lt;p&gt;由于作者长期从事Web前端领域的工作的原因，本文也是基于这些技术领域发出的一些关于应用软件方向上的扩展性总结&lt;/p&gt;
&lt;h2 id=&#34;什么是扩展性设计&#34;&gt;什么是扩展性设计&lt;/h2&gt;
&lt;p&gt;软件架构设计里比较关注的几个要素：&lt;code&gt;扩展性&lt;/code&gt;，&lt;code&gt;稳定性&lt;/code&gt;，&lt;code&gt;可维护性&lt;/code&gt;。很多领域里都会有这方面的考虑。比如：业务架构，产品架构，软件技术架构。那么具体怎么定义呢&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Extensibility is a software engineering and systems design principle where the implementation takes future growth into consideration&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展性是在考虑未来增长发展时所做的一些工程实践和系统设计原则&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;引用自维基百科的定义&lt;/p&gt;
&lt;h2 id=&#34;基础理论&#34;&gt;基础理论&lt;/h2&gt;
&lt;p&gt;这里讨论的理论基础是比较原始的，类似于数学或物理中的定律定理。实践中是要结合具体场景通过组合这里理论，以及基于这些理论做些推导来形成最佳的设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到变化的东西&lt;/li&gt;
&lt;li&gt;solid原则&lt;/li&gt;
&lt;li&gt;分层明确&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常用形式&#34;&gt;常用形式&lt;/h2&gt;
&lt;h3 id=&#34;中间件&#34;&gt;中间件&lt;/h3&gt;
&lt;p&gt;中间件是一种实践比较成熟的形式了。基本的思想是根据一些约定拦截输入，做一些逻辑，或者修改挂载上下文，然后继续向下流。具体的形式上有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;洋葱模型中间件： &lt;code&gt;koa2&lt;/code&gt;， &lt;code&gt;redux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;管道化模型的中间件：&lt;code&gt;pipe&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中间件实践中要考虑的因素是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间件收集方式&lt;/li&gt;
&lt;li&gt;中间件之间的关系，顺序等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插件&#34;&gt;插件&lt;/h3&gt;
&lt;p&gt;这种形式也比较常见。类似于&lt;code&gt;微内核&lt;/code&gt; + &lt;code&gt;plugin/addon&lt;/code&gt; 模型。市面上也存在了很多基于此架构的工具或框架。此模式实践中要考虑的因素是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离性：暴露主应用的那些能力，防止插件的运行影响主应用逻辑&lt;/li&gt;
&lt;li&gt;性能：进程模型设计，是否独立进程运行&lt;/li&gt;
&lt;li&gt;生命周期：插件加载时机，插件执行时机&lt;/li&gt;
&lt;li&gt;插件之间管理：插件之间是否能互相调用，互相影响&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;插件机制思想很简单，重要的是各种实现细节，实践中有不同形式与细节。这里日后单独写一篇文章来分析&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;p&gt;读取配置文件，读取参数都是这种形式。是一种简单但实用的形式。不过多讨论&lt;/p&gt;
&lt;h2 id=&#34;案例分析&#34;&gt;案例分析&lt;/h2&gt;
&lt;h3 id=&#34;webpack中的扩展性设计&#34;&gt;webpack中的扩展性设计&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt; 是一个比较流行的打包工具。其功能的强大，生态的繁荣离不他的插件体系和loader体系。本身作为一个流程控制中心，很多功能都是分散在各个插件里来做的&lt;/p&gt;
&lt;h4 id=&#34;loader体系&#34;&gt;loader体系&lt;/h4&gt;
&lt;p&gt;针对特定的文件类型来做处理的，有点类似上一节提到的&lt;code&gt;管道化中间件模型&lt;/code&gt;。针对特定类型文件可以提供多个，按照顺序管道化的处理转换。&lt;/p&gt;
&lt;h4 id=&#34;插件体系&#34;&gt;插件体系&lt;/h4&gt;
&lt;p&gt;webpack 内部主要的两个概念是 &lt;code&gt;complier&lt;/code&gt;主要负责构建整体流程等，&lt;code&gt;compliton&lt;/code&gt;主要负责构建里的具体编译工作。这两者都是通过 &lt;code&gt;Tapable&lt;/code&gt; 库来完成内部生命周期暴露，&lt;code&gt;Tapable&lt;/code&gt; 大体上是一种 &lt;code&gt;sub-pub&lt;/code&gt; 模式的实现, 其核心概念 hook 可以与 event系统里的某个 event 等价。在同一个hook下可以绑定很多handler的注册，有点像AOP编程思想。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
