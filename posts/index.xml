<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 钟灵毓秀</title>
    <link>https://tomorrowthief.github.io/posts/</link>
    <description>Recent content in Posts on 钟灵毓秀</description>
    <image>
      <url>https://tomorrowthief.github.io/cover.png</url>
      <link>https://tomorrowthief.github.io/cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 30 Dec 2024 13:50:01 +0800</lastBuildDate><atom:link href="https://tomorrowthief.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Devops概念梳理</title>
      <link>https://tomorrowthief.github.io/posts/devops/</link>
      <pubDate>Mon, 30 Dec 2024 13:50:01 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/devops/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Devops 从18年左右发展至今已经非常的成熟。可以作为一个独立职业，因为里面有很多细节。作为互联网软件开发者，我从开发的视角梳理下一些应知应会的框架，主要达到一个能使用，能了解架构，出了问题大概知道在哪个环节。具体细节暂时不追求。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;Docker，是一种容器化的概念，属于虚拟化技术的一种形式。以颗粒度更小的方式，隔离性也更好的方式完成宿主机的资源榨取。他与虚拟机的核心区别是&lt;/p&gt;
&lt;p&gt;Docker与虚拟机的核心区别主要在于以下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;架构层级&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机（Virtual Machine, VM）&lt;/strong&gt;：虚拟机在宿主操作系统之上运行一个完整的客户操作系统。它使用Hypervisor（如VMware、KVM、Hyper-V等）来虚拟化硬件资源，每个虚拟机都有自己的内核、操作系统和应用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：Docker容器在宿主操作系统之上运行，但它们与宿主共享相同的操作系统内核。容器是通过容器引擎（如Docker）来管理和隔离的。每个容器包含应用程序及其所有依赖项，但不包含完整的操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源利用效率&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：由于每个虚拟机都需要一个完整的操作系统，因此启动和运行时会消耗更多的内存和CPU资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：由于所有容器共享宿主操作系统的内核，启动时间更快，资源开销也更小。这使得容器更加轻量级，可以在同样的硬件上运行更多实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动时间&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：由于需要启动一个完整的操作系统，虚拟机通常需要数分钟时间才能完全启动并准备好使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：因为没有完整的OS启动过程，Docker容器通常可以在几秒钟内完成启动。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;隔离性与安全性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：提供了强隔离，因为每个VM运行在完全独立的环境中，包括独立的内核。因此，安全性较高。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：虽然提供了进程级别的隔离，但仍共享宿主OS内核，因此理论上存在一些安全风险。不过，通过适当配置和使用工具（如SELinux、AppArmor等），可以增强安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存储与持久化数据管理方式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：通常使用虚拟磁盘文件来存储数据，这些文件可以独立于其他VM进行管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;：使用卷（volumes）和绑定挂载（bind mounts）来持久化数据，这些可以被多个容器共享或独立管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总而言之，Docker作为一种轻量级、便捷、高效且快速部署的方法，在云原生应用开发中得到了广泛应用。而虚拟机则仍然适用于需要强隔离、安全要求高以及需要运行不同类型操作系统等场景。&lt;/p&gt;
&lt;p&gt;Docker的核心原理是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker的核心原理是利用操作系统级的虚拟化技术（即容器化技术）来创建、部署和运行应用程序。具体来说，Docker 的核心原理包括以下几个方面：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Namespace（命名空间）隔离&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker 使用 Linux 内核的命名空间（Namespace）功能来实现进程隔离。这些命名空间包括 UTS（主机和域名）、IPC（进程间通信）、PID（进程 ID）、Network（网络）、Mount（文件系统挂载点）等。&lt;/li&gt;
&lt;li&gt;每个容器都有独立的命名空间，因此它们之间不会互相干扰，提供了类似虚拟机的隔离效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cgroups（控制组）资源控制&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cgroups 是 Linux 内核提供的一种机制，用于限制、记录和隔离单个进程组的资源使用情况。Docker 使用 Cgroups 来限制容器可以使用的 CPU、内存、磁盘 I/O 等资源。&lt;/li&gt;
&lt;li&gt;通过这种方式，Docker 能够确保每个容器在资源分配上互不干扰，并且可以避免某个容器滥用系统资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Union File System（联合文件系统）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker 使用联合文件系统，如 AUFS、OverlayFS 等，来实现镜像和容器的分层存储。每个 Docker 镜像由多层组成，每一层都是只读的，当需要对镜像进行修改时，会在顶层添加一个可写层。&lt;/li&gt;
&lt;li&gt;这种分层设计不仅提高了存储效率，还使得镜像可以快速构建和共享。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Container Image（容器镜像）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器镜像是一个包含应用程序及其所有依赖项的只读模板。Docker 容器是从这些镜像创建出来的一种运行实例。&lt;/li&gt;
&lt;li&gt;镜像可以通过 Dockerfile 定义，并且支持版本管理，这使得应用程序环境变得可移植且易于复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Container Runtime&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LLM 长记忆工具总结</title>
      <link>https://tomorrowthief.github.io/posts/ai-longterm-memory/</link>
      <pubDate>Sat, 19 Oct 2024 11:48:00 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-longterm-memory/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;p&gt;近期工作中做了 LLM 长记忆功能，对此中的思路，技术做下总结。顺便为了练习自己的系统设计能力，这里按照系统设计的方式来整理&lt;/p&gt;
&lt;h2 id=&#34;什么是长记忆&#34;&gt;什么是长记忆&lt;/h2&gt;
&lt;p&gt;简单来说就是让大模型具备记忆功能，记住某个人。产品形态上可以是个人助手。不同于某次会话上下文记忆，长记忆具备的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跟随个人的：我们目前常见的短期记忆只是跟随某次会话&lt;/li&gt;
&lt;li&gt;时间长：1年，5年，10年，……，终生&lt;/li&gt;
&lt;li&gt;个人信息相关的：比如个人爱好，心情变化，健康，工作，生活等这些属于个人记忆。客观信息事实信息比如：美国在北美洲，地球是圆的等这些不需要作为记忆信息。&lt;/li&gt;
&lt;li&gt;多种类型的：如上条有不同类型的记忆，不同类型的记忆里处理方式有很大差异，比如：日程相关的需要处理时间，绝对时间的转换，个人爱好相关的，比较简单，直接用类似图谱的三元组信息即可，办公工作内容型的记忆类似。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;功能点及非功能点梳理&#34;&gt;功能点及非功能点梳理&lt;/h2&gt;
&lt;p&gt;总体其实为了实现个人助手的产品功能。这个助手在产品形态上是一个普通对话机器人，系统的具备的功能及非功能点需求大致如下：&lt;/p&gt;
&lt;h3 id=&#34;功能点&#34;&gt;功能点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;登录，因为是私人助手嘛，得知道用户是谁。&lt;/li&gt;
&lt;li&gt;对话：这个不用说了，是助手的主题功能&lt;/li&gt;
&lt;li&gt;配置功能，因为记忆有很多种类型，在助手里最好有配置，比如我想主要是工作，那日程安排比较重要，生活。如果多有记忆都要配置，那就是一个超级个人助手&lt;/li&gt;
&lt;li&gt;记忆生产：根据配置信息，做不同类型的记忆提取存储&lt;/li&gt;
&lt;li&gt;记忆消费：是指根据记忆：做下健康管理，饮食管理，工作学习计划，日程计划，等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;非功能点&#34;&gt;非功能点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;短期能同时处理 1w+ 人数的并发，长期的话人数可能扩充到 10W+，甚至更多。每天可能有 50W 的请求&lt;/li&gt;
&lt;li&gt;响应时间：在记忆消费时能做到 3s - 5s 内有响应，3s-30s 内响应完成。&lt;/li&gt;
&lt;li&gt;数据规模，根据每个人的配置，记忆长短不同，数据规模有不同要求&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;p&gt;工作流程图&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://tomorrowthief.github.io/long-term-memory.png&#34; alt=&#34;Alt text&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;如图所示。总体为一个 RAG 流程，其中核心是记忆引擎的部分。由于rag流程基础的东西，在社区里做的比较多，也比较简单，不做过多强调。核心强调记忆引擎的东西。&lt;/p&gt;
&lt;h2 id=&#34;记忆引擎&#34;&gt;记忆引擎&lt;/h2&gt;
&lt;p&gt;记忆引擎里完成的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记忆生产
根据配置信息生产一些垂类记忆&lt;/li&gt;
&lt;li&gt;记忆存储
把记忆抽出来后&lt;/li&gt;
&lt;li&gt;记忆消费
根据用户的问题，召回相关的记忆，并做简单推理规划&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;记忆生产&#34;&gt;记忆生产&lt;/h3&gt;
&lt;p&gt;这里输入是会话信息，需要做的是从会话信息里提取记忆实体。主要涉及到自然语言处理的部分。
知识图谱，我们使用知识图谱来完成记忆的载体。&lt;/p&gt;
&lt;p&gt;知识图谱的实体抽取，以及图数据库语法都是用额外的大模型来推理完成&lt;/p&gt;
&lt;h4 id=&#34;提示词设计&#34;&gt;提示词设计&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 信息抽取
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;sb&#34;&gt;`
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        你是一个信息提取专家
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        用户的输入如下：{query}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        实体信息：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;    `&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 记忆更新
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;sb&#34;&gt;`
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        你是一个图数据专家，请生成neo4j的sql语句
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        历史记忆如下：{memories}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        新的记忆如下：{memory}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;        sql:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sb&#34;&gt;    `&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里只给出部分，因为其他一些垂类的内容。其他还有很多，也算是核心。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>后端开发经验-阶段性总结思考</title>
      <link>https://tomorrowthief.github.io/posts/ai-backend-dev/</link>
      <pubDate>Sun, 22 Sep 2024 10:48:00 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-backend-dev/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;p&gt;做了大半年左右的后端开发后，总结下相关感受。&lt;/p&gt;
&lt;p&gt;技术栈：Python/Nodejs + React&lt;/p&gt;
&lt;p&gt;行业背景：LLM 应用， RAG， Agent&lt;/p&gt;
&lt;h2 id=&#34;后端开发思路&#34;&gt;后端开发思路&lt;/h2&gt;
&lt;p&gt;后端关注面更广范，几乎要关注整个应用软件运行所需所有的环节： 运维，应用，业务，服务，UI 等。&lt;/p&gt;
&lt;p&gt;其中核心工作流在于：充分理解需求，转换业务需求到系统的功能性设计及非功能指标设计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能设计上主要关注：数据结构，类包，业务模块，工作流等&lt;/li&gt;
&lt;li&gt;非功能性关注：性能，并发，安全，稳定等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;玩的是数据&#34;&gt;玩的是数据&lt;/h2&gt;
&lt;p&gt;数据算是核心中的核心了。所有的业务基础都是按照这个来的&lt;/p&gt;
&lt;h3 id=&#34;关系型业务&#34;&gt;关系型业务&lt;/h3&gt;
&lt;p&gt;mysql 或者 pg，选一个吧，这里我还没遇到两者特别大的差异的地方，因为我的业务场景里没那么复杂&lt;/p&gt;
&lt;p&gt;这里主要考虑：表结构设计，索引设计。&lt;/p&gt;
&lt;p&gt;如果到一定规模考虑 分区，分表，分库&lt;/p&gt;
&lt;p&gt;实际业务中大多需要找一个 ORM 库来完成在应用里方便的操作。&lt;/p&gt;
&lt;p&gt;如果有 Redis 或者其他异步复杂的事务处理，需要进一步考虑数据一致性。&lt;/p&gt;
&lt;h3 id=&#34;非关系&#34;&gt;非关系&lt;/h3&gt;
&lt;p&gt;Redis，Es，Mongodb，图数据库&lt;/p&gt;
&lt;p&gt;日志相关的一般存放到 mongodb 或者es，由于他们在倒排索引的效果做的比较好，方便快速全文索引，海量存储。&lt;/p&gt;
&lt;p&gt;Redis：内存数据库，来缓解在 mysql里不经常变动，又频繁查询的操作压力。当然他也可以做一些简单的消息中间件等&lt;/p&gt;
&lt;p&gt;图数据库&lt;/p&gt;
&lt;p&gt;在一些场景里需要做知识图谱，做关系，图数据库特别适合。这里核心是实体关系等三元组信息抽取，已有知识更新。得益于大模型这个第二大脑的配合，可以通过提示词让LLM帮我们去做实体抽取，三元组信息变得简单很多&lt;/p&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;这块也是一个非常大的技术体系，往深走的话需要专题讨论。&lt;/p&gt;
&lt;p&gt;我这边是入门不久，着重看了 Mysql 执行引擎的内容，B+ 索引的来由。练习了常用 SQL 语法（leetcode 50高频sql）&lt;/p&gt;
&lt;p&gt;由于之前了解过大数据基础知识，所以对于我前端出身学习这块，难度不大。&lt;/p&gt;
&lt;h2 id=&#34;一些中间件&#34;&gt;一些中间件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;消息中间件
几乎是必须的，做异步，服务结构等&lt;/li&gt;
&lt;li&gt;任务队列
做性能，并发等&lt;/li&gt;
&lt;li&gt;日志，错误处理等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;微服务体系&#34;&gt;微服务体系&lt;/h2&gt;
&lt;p&gt;很多公司其他基础模块都是基于微服务的方式提供的。系统扩充到一定程度肯定少不了微服务架构的梳理&lt;/p&gt;
&lt;p&gt;得益于 Service Mesh 这种微服务2.0架构。做上层应用变得异常简单了。日志，监控，服务注册调用 等都在 SideCar里&lt;/p&gt;
&lt;p&gt;我之前有过 Nodejs 接入微服务体系的经验，所以这块难度也不是特比大&lt;/p&gt;
&lt;h2 id=&#34;计算机基础&#34;&gt;计算机基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算机组成：cpu，gpu，硬盘，内存&lt;/li&gt;
&lt;li&gt;操作系统：进程线程协程等，资源管理，IO管理：网络/文件&lt;/li&gt;
&lt;li&gt;编译：前端：分词，语法分析，语法树，后端：机器平台生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式-时间空间互换&#34;&gt;分布式-时间空间互换&lt;/h2&gt;
&lt;p&gt;这里我觉得是计算机性能上一个很重要的思路，在优先的单机资源下实现高复杂度计算的模式。大数据的基石 Hadoop也是这个核心思想。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>苏东坡</title>
      <link>https://tomorrowthief.github.io/posts/sudongpo/</link>
      <pubDate>Sun, 30 Jun 2024 09:13:27 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/sudongpo/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;林语堂苏东坡读后感&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入偶然原因看了些苏词，同时也看了林语堂的苏轼传，这里记录下所感，所想。重点不是描述豪放的苏词，而是苏轼这种人才的优点，缺点。苏轼若是在当代社会又是咋样的？&lt;/p&gt;
&lt;h2 id=&#34;大概过下苏轼传&#34;&gt;大概过下「苏轼传」&lt;/h2&gt;
&lt;p&gt;苏轼传记有很多，各种角度去描写的，我选择了林语堂的这本。林语堂是民国时期著名文科生，特点中外双休，说来奇怪，他写的苏轼传是用英语写的，或许是为了向世界科普这个中国巨星。而我读的却是一个国人的译本。既然是面向世界的，选择的角度肯定不太一样了，也会拿西方的文豪大家与苏轼对比。&lt;/p&gt;
&lt;p&gt;这本书里不像一些其他书，用很多首苏词来作为切入点，描写。他直接以苏轼的视角，按照时间线，穿插一些中间人物大事记（弟弟苏澈，伯乐欧阳修，政敌王安石，他的三任夫人，等等），来完成的，也加了不少北宋的政治经济背景，各个皇帝的特点等。所以读下来就是一个北宋中后期的国家命脉缩略。&lt;/p&gt;
&lt;h2 id=&#34;不止于诗词&#34;&gt;不止于诗词&lt;/h2&gt;
&lt;p&gt;苏轼写词，写诗，是他的立命之本。他的年代是文学的时代，家族里也有好的基因，氛围。他叔已经是当官的，他爸虽然无官，但是唐宋八大家之一，他爸的六国论，他妈的思想已经不是普通妇人的思想了。&lt;/p&gt;
&lt;p&gt;如此的家境放到现在，如果不是特别不着调，抬也能给抬到一个合适的位置。况且他和弟弟在立命之学的年纪里一起下了重功夫，使得他基础太扎实了，所有文字创作信手拈来。任何行业都需要一个扎实的基本功，才能有上层轻松的创作，作家，歌手，程序员，运动员，哪个不是呢?&lt;/p&gt;
&lt;p&gt;他呢，让人津津乐道的不止于诗词。乐天派，豪放派的作风。到哪里都有朋友。喜爱喝酒。也会接触名妓。说到这里，我是觉得不能单纯看他的这些特点，结合他背景：少年成才，国家顶级人才，得到皇帝的大力认可，可谓前途无量。体验过生而为人的巅峰，这个自信自然养成了，也早已脱离了为生计奔波的烦恼。所以即便有在政治斗争里的一贬再贬再再贬，那都不是事。&lt;/p&gt;
&lt;p&gt;林语堂描写他的政论也是一流的，这个是位难得，宋朝不缺文学，但是文学和政论都很好的就少了，范仲淹，欧阳修，司马光，王安石都算是，苏轼当然也算，他的特点似乎是更接地气，更是站在底层大众这一侧。实事求是，真正做事的人。&lt;/p&gt;
&lt;p&gt;他对生活很热爱，对细节观察也很到位，体现在诗词里，也体现在他的书法与国画里，他是南方国画鼻祖。国画里对动物的传神，对山水天人合一的追求，要求作者必须对细节观察做到细致入微。&lt;/p&gt;
&lt;h2 id=&#34;能跟任何人玩到一起&#34;&gt;能跟任何人玩到一起&lt;/h2&gt;
&lt;p&gt;书里一个章节：和尚，酒与名妓，来形容他的爱好，形容的真好。他结交了很多僧人，与他们聊思想，交换灵魂。或许这点也是构成他性格的重要瓦片。他朋友圈里很多都是追随他的，比如苏门四学士等。&lt;/p&gt;
&lt;p&gt;皇帝点过他的名，嫉妒者们对他一再打压，太后出于女人第六感，认为他是一个可靠之才，恢复他的官位。他有很多酒友每到一个地方，都不缺朋友，分布到各阶层里。&lt;/p&gt;
&lt;p&gt;他与头号政敌王安石，最后也能畅谈下想法。&lt;/p&gt;
&lt;h2 id=&#34;他也是一个普通人&#34;&gt;他也是一个普通人&lt;/h2&gt;
&lt;p&gt;本质上他也是追求名利，没有得到的时候也会迷茫，有了机会的时候也会努力抓住的。在遇到乌台诗案的时候，他也是慌不知所措，内心是恐惧的，害怕死亡，更害怕家人受到牵连。&lt;/p&gt;
&lt;p&gt;作为一个动物，他也是爱好吃喝的。人生中后期也追求长生不老之术，每次被贬也都带了很多家人一起，这点来看条件已经不错了，比起当时草民生活上强了太多。&lt;/p&gt;
&lt;p&gt;也正是一个普通人的特点，才愿意被更多人追随吧，才能被千年后的我们依然喜欢。&lt;/p&gt;
&lt;h2 id=&#34;再无苏轼&#34;&gt;再无苏轼&lt;/h2&gt;
&lt;p&gt;一个现代社会里很难再出现苏轼这样的人了。首先培养出这样的人才需要巨大的精力，其次在阶层固化，大众追求的理想已经很难到达苏轼这种高度了。于我们苏轼的故事当作聊天语料，当作精神参考，其作品当作我们引经据典的素材，足以。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 学习总结</title>
      <link>https://tomorrowthief.github.io/posts/ai-python/</link>
      <pubDate>Sat, 22 Jun 2024 10:47:41 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-python/</guid>
      <description>&lt;h2 id=&#34;为什么要学-python&#34;&gt;为什么要学 Python&lt;/h2&gt;
&lt;p&gt;最近开始接触 Ai 相关的东西。主要是应用层的内容，比如 RAG Agent 等。此类应用特点：无需太多安全性能，偏向于工具，这块技术发展变化比较迅速，大模型日新月异，应用层技术也跟随变化较多。&lt;/p&gt;
&lt;p&gt;根据此特点选择脚本类型语言作为应用层开发语言。待选语言有 &lt;code&gt;Nodejs&lt;/code&gt; &lt;code&gt;python&lt;/code&gt;。 个人虽熟悉 Nodejs，但鉴于 Python 生态较好 性能较好等，最后决定 Python。&lt;/p&gt;
&lt;h2 id=&#34;python-综述&#34;&gt;Python 综述&lt;/h2&gt;
&lt;p&gt;Python 第一版本发布于 2000年，目前在 Tiobe 排行榜里人数排名第一，社区热度也升为第一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定位：高级语言，通用能力编程语言&lt;/li&gt;
&lt;li&gt;特性：动态语言，基于解释器，gc 等&lt;/li&gt;
&lt;li&gt;范式：函数编程，面向对象，面向过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要在 数据处理，计算，Web等发挥作用，AI 领域使用很多， Web 开发也有很多场景&lt;/p&gt;
&lt;p&gt;运行模式支持 多进程，多线程，协程&lt;/p&gt;
&lt;h2 id=&#34;执行流程&#34;&gt;执行流程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这一章直接问了 gpt，下面都是 ai 的回答&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Python中，程序的执行流程通常是按照以下步骤进行的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;解释器读取源代码：Python解释器会逐行读取源代码文件，并将其转换为字节码形式，这是一种中间表示形式，可以被Python虚拟机执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;词法分析和语法分析：在这个阶段，Python解释器会将源代码分解成单词（Token）并构建语法树。这个过程包括词法分析（将源代码分解为Token）和语法分析（根据语法规则构建语法树）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译字节码：Python解释器将语法树转换为字节码。字节码是一种中间形式，类似于机器码，但是不是针对特定的硬件架构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行字节码：Python虚拟机执行字节码指令。这些指令会被逐条执行，从而实现程序的逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态类型检查：Python是一种动态类型语言，因此在运行时会进行类型检查。如果类型不匹配，会引发类型错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垃圾回收：Python具有自动内存管理机制，包括垃圾回收。垃圾回收器会定期检查不再使用的内存对象，并释放它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常处理：在程序执行过程中，如果发生异常，Python会查找合适的异常处理程序。如果找不到合适的处理程序，程序会中止并打印错误信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序结束：当程序执行完所有的代码或遇到显式的退出语句（如return或sys.exit()）时，程序结束执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;p&gt;跟我熟悉的 JS 差别很大，总体感受很灵活。基础的比如：变量 循环，函数的定义参数。可以直接看&lt;a href=&#34;https://docs.python.org/zh-cn/3/reference/index.html&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人感觉 1-2 周左右时间，即可上手基础开发。&lt;/p&gt;
&lt;p&gt;这里只提下我印象比较深刻的函数部分：
通过 def 定义，通过缩进写函数体，当然也可以添加类型系统，比如入参数类型，返回类型。基础demo如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数参数可以用 &lt;code&gt;*&lt;/code&gt; &lt;code&gt;*key_yars&lt;/code&gt; 来动态接收&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AI应用实践的思考</title>
      <link>https://tomorrowthief.github.io/posts/ai-work-thought/</link>
      <pubDate>Fri, 22 Mar 2024 09:16:11 +0000</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/ai-work-thought/</guid>
      <description>&lt;p&gt;近两年AI太火了，认真体验及分析后, 决定尽量跟上, 最少要把相关工具使用好。恰好工作中也在做相关工具，遂梳理之, 以加深对这块的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;打败马车夫的不是汽车本身，而是会开车的司机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;生成式ai的爆发&#34;&gt;生成式AI的爆发&lt;/h2&gt;
&lt;p&gt;AI 这个领域很早就开始了，这个理念也很早就有了，比如早期图像处理，语音识别，阿尔法go等。可以回溯之前很多年。为何最近两年开始爆火了。我认为原因有几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;技术突破&lt;/strong&gt;: 大模型的底层基于神经网络的深度学习推出了 transformer 架构。改变了大模型深度学习的格局带来了质的飞跃&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础设施发展&lt;/strong&gt;: 一个模型巨量的计算，消耗大量资源。硬件基础设施的发展能降低训练成本，试错成本，让更多想法去实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据的积累&lt;/strong&gt;: 互联网发展至今产生了大量数据，可以作为训练知识来让模型学习，这些都是人类发展产生的财富。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简单说下-transformer&#34;&gt;简单说下 Transformer&lt;/h3&gt;
&lt;p&gt;最早是在论文 &lt;code&gt;Attention is all you need&lt;/code&gt; 提出注意力的机，以解决在序列生成中，长序列情况下的精度，简单一点来说是通过空间位置编码，扩充之前神经网络里的一些信息，使得即使再有更多长度，也不会让精度下降。&lt;/p&gt;
&lt;p&gt;现代架构里添加了很多其他模块：比如多头自注意力机制，并行机制等。&lt;/p&gt;
&lt;p&gt;总之结果是：推理精读更好，训练效率更高。这是当今 AIGC 爆发的技术基础&lt;/p&gt;
&lt;h2 id=&#34;能改变什么&#34;&gt;能改变什么&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有人说任何行业都可以重新再做一遍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人类的进步，从来离不开工具，有了轮子就有了车，马车，有了蒸汽机就有了汽车，这些都是革命性的改进，都是依赖工具的。工具改变了生产力，进一步质变为影响生产关系。促进了社会整体变化。&lt;/p&gt;
&lt;p&gt;总结下来当前影响最大的几个面：&lt;/p&gt;
&lt;h3 id=&#34;广告自媒体行业的商业模式&#34;&gt;广告/自媒体行业的商业模式&lt;/h3&gt;
&lt;p&gt;剪辑，修图，这种体力活完全可以用AI帮忙做了&lt;/p&gt;
&lt;h3 id=&#34;教育教培学习方式&#34;&gt;教育教培，学习方式&lt;/h3&gt;
&lt;p&gt;对于家长可以用 AI 辅助教养小孩子，学生也可以方便的用AI自助学习。&lt;/p&gt;
&lt;h3 id=&#34;工作效率提升&#34;&gt;工作效率提升&lt;/h3&gt;
&lt;p&gt;有些细节直接用AI生成即可，员工负责更高一层的控制&lt;/p&gt;
&lt;h3 id=&#34;软件开发程序员&#34;&gt;软件开发程序员&lt;/h3&gt;
&lt;p&gt;我本身就在程序员行当里，对这个提效深有体会&lt;/p&gt;
&lt;h2 id=&#34;局限性&#34;&gt;局限性&lt;/h2&gt;
&lt;p&gt;正如人类能想象到的东西都是现有认知范围内现有知识体系内的东西一样，AI 学习能力目前还处于理解现有知识体系的状态。无法突破知识界限，只有在有限的知识范围内做一个最强大脑。
所以局限性在于，他只是一个只能基于现有知识的超强大脑，无法升维无法突破边界。
当然如果有了一个这样超强大脑，本身就是一件很厉害的事情。至于突破编辑，升维知识，这个还要考我们人类，然后再喂给AI，形成一个循环。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一旦AI具备 公理，定律等级别的创新，是非常恐怖的，人类的一切迷惑将不再是迷惑，我是谁？来自哪里？要去哪里？上帝是谁，造物主是谁，各方神灵，神明又是谁？宇宙之外在哪里？生命是什么？为什么活着，为啥又要死去&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;模型&#34;&gt;模型&lt;/h2&gt;
&lt;p&gt;百花齐放，百家争鸣。通用，垂类，领域模型等太多了，发展过于迅速，具体模型此处不多谈。&lt;/p&gt;
&lt;p&gt;要谈的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度学习模式的变革，基于 Transformer 架构的深度学习促进了当下模型厂商的发展，多层 Transformer 架构使得大模型更像人类大脑。&lt;/li&gt;
&lt;li&gt;向量化，万事万物皆是向量，皆是数据，向量这个结构让事物之间的关系拉平了。就像分子，化学元素一样，构成了物质世界，而向量则在虚拟世界里描述这个世界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这两个重要的底层知识，模型的发展，飞起来了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;菩提本无树，明镜亦非台，本来无一物，何处惹尘埃&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ai应用&#34;&gt;AI应用&lt;/h2&gt;
&lt;p&gt;大模型还毕竟只是一个最强大脑，一个超强CPU。我们知道通用计算机，不止CPU，还有一些外围设备才能通用工作，人类也是，不止大脑，还有眼睛，手，等外围设备。&lt;/p&gt;
&lt;p&gt;所以 AI 应用，或则 Agent 的概念，可以如此类比。&lt;/p&gt;
&lt;h2 id=&#34;技术工具&#34;&gt;技术工具&lt;/h2&gt;
&lt;p&gt;开源的技术工具很多，目前我在用 Langchain。但是不能局限于这些上层工具&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>了凡四训</title>
      <link>https://tomorrowthief.github.io/posts/liaofansixun/</link>
      <pubDate>Wed, 01 Nov 2023 14:09:41 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/liaofansixun/</guid>
      <description>&lt;p&gt;此为一种劝诫训子的书，主要方向是如何处事，也可以是一本养心之书。从中国传统价值观及儒释道的哲学体系来讲述如何处事。总体分为四部分。&lt;/p&gt;
&lt;p&gt;作者是明万历期，69岁时所著。推荐此书的名人：曾国藩，据说其号 &lt;code&gt;涤生&lt;/code&gt; 就是因为此书而来；稻盛和夫等。&lt;/p&gt;
&lt;p&gt;阅读建议：作为枕边书，或者心静的时候细读。&lt;/p&gt;
&lt;h2 id=&#34;分篇章总结&#34;&gt;分篇章总结&lt;/h2&gt;
&lt;h3 id=&#34;立命之学&#34;&gt;立命之学&lt;/h3&gt;
&lt;p&gt;此为开篇，作者以自己早起人生经历，讲述处事流程中第一个阶段：立命。非常重要的人生阶段，大概人与人的差距也会在此拉开。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我命由我不由天&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇最重要的概念了算是。具体一点就是命运是自己把握的。这一点估计现代人看到后会有很多反对点：起跑线不一样，人生结局可大大不同了。&lt;/p&gt;
&lt;p&gt;我的理解是：天生给到的东西已成定行，无法改变。但是之后的情形，还需通过自身不断学习，不断发展来改变。我们尽量做好能做的，其他的只能坦然接受。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;弃医从文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;改变医生的方向，发展仕途的方向。中国历来都是学而优则仕，其他都是歧途。当下路子多了起来，但是遇到环境恶略的时候，发现还得是公务员稳啊。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持续学习&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文中讲到：顺利时也不要忘记努力发展，说不定啥时候不顺就来了。跟当下持续学习的概念不谋而合。随时准备拥抱变化，唯有持续学习，持续适应才能得心应手。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不念过往&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从前种种譬如昨日死，往后种种譬如今日生。&lt;/p&gt;
&lt;h3 id=&#34;改过之法&#34;&gt;改过之法&lt;/h3&gt;
&lt;p&gt;内心，真心，是前提。我觉得这一篇是重要紧急四象限的第二象限里的东西，很重要，也很容易忽略而没做好，应该是我们每天首要考虑的东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先有耻辱感&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否曲直，做一个有原则的人&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发自内心的行动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否是真的在做，还是在模仿，还是在做一个样子。改过之行，来不得半点虚伪。&lt;/p&gt;
&lt;h3 id=&#34;积善之方&#34;&gt;积善之方&lt;/h3&gt;
&lt;p&gt;这一篇里讲述了要行善，行什么善，从十种角度来分析 善，区别什么是善，如何下后。此篇结构简单，但是内容较多，可以选择行阅读&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但行好事莫问前程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇是很佛教里的思想了，善有善报恶有恶报。我不敢苟同这个观点，现实遇到太多事情违背这个理论了。&lt;/p&gt;
&lt;p&gt;但是我觉得行善还是有必要做的。并不是为了有善报，也不会因为你行了善就会有善报。最起码不要去做恶吧，能有一份心安理得不就够了么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不平等的地方太多了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;社会上不平等的地方很多。若你可能是占便宜的一方，你会怎么想，而你是吃亏的一方，你又怎么想？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;做事情不可太功利&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;太过于功利，可能会变形。读一本书就想获得人生智慧，学一个技能就想发财致富，别想了。&lt;/p&gt;
&lt;h3 id=&#34;谦德之效&#34;&gt;谦德之效&lt;/h3&gt;
&lt;p&gt;为人要低调的方式。不要轻易显山露水，少说话多干事。勿要恃才傲物，做事抱有空杯心态，虚怀若谷。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这本书，于我作为一本修心的书去阅读。对于有些人会问值不值得读，我觉得非常值得。但书和道理是死的。看你怎么理解消化了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从前种种, 譬如昨日死; 以后种种, 譬如今日生.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>再读六国论</title>
      <link>https://tomorrowthief.github.io/posts/liuguolun/</link>
      <pubDate>Mon, 16 Jan 2023 10:43:11 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/liuguolun/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;六国破灭非并不利战不善，弊在赂秦……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;近日偶然重新看了这篇文章。再细读后，才发现其文风犀利，逻辑清晰，论点简明有力。虽作为高中时期的教材，那会儿跟不懂内容只知道背诵那些文字，再读后有种相见恨晚的感觉。&lt;/p&gt;
&lt;p&gt;全文读下来感觉朗朗上口，思路清晰，逻辑感也很强。是一篇非常好的议论文。&lt;/p&gt;
&lt;h2 id=&#34;一些文段&#34;&gt;一些文段&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;今日割五城，明日割十城，然后换得一夕安寝。起视四境，而秦兵又至。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用物质消灭贪婪是不可能的，犹抱薪救火，薪不尽火不灭。讲的是人的贪婪欲望是无限的，一味的去迎合这些，那就会陷入无底洞。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以赂秦之地封天下之谋臣，以事秦之心礼天下奇才，并力向西。则吾恐秦人食之不得下咽也&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里想到了一个公司内耗严重的时候，将这些内耗的精力拿到做应该做的事情，才是公司团队应该的做法。&lt;/p&gt;
&lt;h2 id=&#34;个体利益与群体利益&#34;&gt;个体利益与群体利益&lt;/h2&gt;
&lt;p&gt;上面那个道理我想很多人都会懂，但是为什么现实中还是会陷入内耗中。我觉得是一些人性本质问题: 为什么要你过的比我好，我玩不了，大家也都别想玩，所谓&lt;code&gt;不患寡而患不均&lt;/code&gt;。另外就是在总的资源有限人又很多的时候，每个人都为了生存不得选择了个体利益优先的决定。&lt;/p&gt;
&lt;p&gt;这种能做到全局最佳解的方式，目前只发现了蚂蚁，蜜蜂这些动物群体做好。一方面因为这些动物单个个体是没有思想的，生来机械的负责一些事情。而人类是有思想的有感情的，在这些生存决策前往往会选择只符合单一个体利益的情况。&lt;/p&gt;
&lt;p&gt;六国论里这个观点在理性上是全局最合理的，但是考虑到现实中人的本性问题，每个国家都有各自的想法，思想。最终的决策往往是不合乎理性的。&lt;/p&gt;
&lt;p&gt;所以我觉得六国破灭的另一个深层次的因素是人性本质问题，而要解决这个问题需要&lt;code&gt;合&lt;/code&gt;。要有个唯一负责人来调度各国，形成统一战力&lt;/p&gt;
&lt;h2 id=&#34;公司里的六国&#34;&gt;公司里的六国&lt;/h2&gt;
&lt;p&gt;公司内部各个部门众多，单个部门想推动全局做好一件事情是比较困难的，这里最好通过一个总指挥的制度去推进事情。然而事实中关系错中复杂，身处此中的你我大多选择苟活，如此跟六国中的赂秦战术并无大的区别&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>孙子兵法-研习记</title>
      <link>https://tomorrowthief.github.io/posts/art-of-war/</link>
      <pubDate>Fri, 17 Jun 2022 10:08:36 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/art-of-war/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;近日工作不忙，偶然看到孙子兵法一书，印象里面应是各种打打杀杀，由无他事就读了一些，发现并不是那么简单。
博主在上下班路上，前后半个月的时间学习了一些。为了加深自己的记忆，理解。就梳理了这篇札记&lt;/p&gt;
&lt;h2 id=&#34;孙子兵法-是什么&#34;&gt;孙子兵法 是什么&lt;/h2&gt;
&lt;p&gt;孙子兵法是一本信息熵极高的阐述战争方法论的书，原文仅 6000 余字。经过之后两千多年时间沉淀：注解引申，国内外各大名家的参与，现在已经形成了一个&lt;code&gt;战争理论生态&lt;/code&gt;，&lt;code&gt;战争方法论&lt;/code&gt;。这里说的战争可以是冷兵器时代的战争，也可以是强调技术装备，信息化的&lt;code&gt;现在战争&lt;/code&gt;，也可以是&lt;code&gt;商战&lt;/code&gt;，&lt;code&gt;工作职场&lt;/code&gt;，&lt;code&gt;学业&lt;/code&gt;，&lt;code&gt;投资&lt;/code&gt;。现在已经翻译了多国语言，据说在国外也比较流行，认可度极高。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;适读人群: 最好是有一定工作生活经验的人，如果是单纯的学生不建议阅读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;架构图&#34;&gt;架构图&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://pic1.zhimg.com/80/31b844f5d5119c1d9abfb8dd91cb31c6_1440w.jpg?source=1940ef5c&#34; alt=&#34;架构图&#34;  /&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注此图引自知乎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;首先-不去战争&#34;&gt;首先-不去战争&lt;/h3&gt;
&lt;p&gt;孙子兵法首要强调的是&lt;code&gt;不战而胜&lt;/code&gt;，因为战争成本太高代价太大。特等医生的价值不是体现在治病救人，而是在生病前防疫工作：如何不得病，如何尽早发现病并及时治理。当然这里不是贬低治病救人的技术，只是我们经常忽略准备防疫的重要性，到了生病时候才发现代价真的太大。所以孙子兵法虽然是一本兵书，却比较强调怎么不去战争，规避战争，强调的是：&lt;code&gt;日积月累&lt;/code&gt;，&lt;code&gt;有备无患&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;作战原则&#34;&gt;作战原则&lt;/h3&gt;
&lt;p&gt;实际中战斗是不可避免的。如何做好呢？战斗就像做事做人。孙子兵法全文里强调三大原则：&lt;code&gt;知己知彼&lt;/code&gt;, &lt;code&gt;先胜后站&lt;/code&gt;, &lt;code&gt;至人而不至于人&lt;/code&gt;。很多具体章节里都是为了满足遵循这几个原则的，所以理解透了这些原则思想，一切满足此的都可以称为好兵法。&lt;/p&gt;
&lt;p&gt;就像软件架构里的设计模式 &lt;code&gt;solid&lt;/code&gt; 原则，很多具体的模式都是为了满足实现&lt;code&gt;solid&lt;/code&gt;原则。这些原则是贯穿整体的&lt;/p&gt;
&lt;p&gt;工作中需要做参考别的技术，大多是学习了别人的思想，别人的原则，然后根据自己的情况实现一套可行的方案。&lt;/p&gt;
&lt;h3 id=&#34;基本面&#34;&gt;基本面&lt;/h3&gt;
&lt;p&gt;战前准备的方法论：五事七计(具体看上面架构图)。运筹帷幄，庙堂之上充分分析各个因素，最后制定出最有利的战斗计划。&lt;/p&gt;
&lt;p&gt;如同我们在做编码设计，或则项目时，基本都是先尽可能做好详设计，而这些又是比较耗费精力的。最后写代码具体工作却是很快的。倘若设计阶段没做好，后面很可能比较被动，代码自量也难以保证，返工之类的。&lt;/p&gt;
&lt;h3 id=&#34;操作面&#34;&gt;操作面&lt;/h3&gt;
&lt;p&gt;有了五十七计，胜负因素方向已定。而战场却又千变万化，影响因素也不计其数。就要因地制宜的去发挥。孙子兵法里提出有行军，九地九变等，都是讲一些具体情况下的做法。&lt;/p&gt;
&lt;p&gt;这里我理解我们工作尤其是互联网这种变化较多工作，必须要做好抬头看路的工作。把握政策情况，市场情况，个人成长情况然后做好自己的规划。&lt;/p&gt;
&lt;h2 id=&#34;个人收获&#34;&gt;个人收获&lt;/h2&gt;
&lt;p&gt;收获还是挺多：明确了做事的 原则，系统分析法所谓方法论，底层逻辑。以及该做哪些事情，不该做哪些事情的取舍&lt;/p&gt;
&lt;h3 id=&#34;不要忽略基本面&#34;&gt;不要忽略基本面&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;善战者,无智名,无勇功&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人们往往比较喜欢波澜壮阔的故事，而忽略基本面的作用。比如我们喜欢韩信背水一战的故事，但是从理论来上看是违背 &lt;code&gt;五事七计&lt;/code&gt; 的分析。诸葛亮出师北伐的例子也是在基本面上就输了，汉武大帝的传奇一生，却耗费了文景之治的积累，所谓一将功成万骨枯。&lt;/p&gt;
&lt;p&gt;古今中外精彩故事也不少，但那是2000多年的历史积累，更多的是默默无闻却又贡献很多的平淡故事&lt;/p&gt;
&lt;p&gt;我们每个人也一样，绝大多数都是平凡平淡的。但是能把基础面做好，有一份好的学业，经营一份自己的工作事业，有个好的身体健康素质，已经能达到生活的意义&lt;/p&gt;
&lt;h3 id=&#34;准备的重要性&#34;&gt;准备的重要性&lt;/h3&gt;
&lt;p&gt;这里说的准备更多是: &lt;code&gt;五事七计&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;做管理: 考虑编制是如何的，组织架构怎样设计&lt;/li&gt;
&lt;li&gt;带团队: 考虑梯队模型时分析成员画像，如五事里的&lt;code&gt;将&lt;/code&gt;的能力模型定义：&lt;code&gt;智信仁严勇&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;做项目: 考虑项目以来的技术，团队，项目本身的ROI等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;知己知彼-难在知己&#34;&gt;知己知彼 难在知己&lt;/h3&gt;
&lt;p&gt;自己能决定失败，对手才能决定能否胜利。&lt;/p&gt;
&lt;p&gt;在势均力敌的时候，对手不犯错一般自己很难胜利。所以说胜利是看对手有没有犯错。对应的，自己的一些准备日常是决定自己能不能失败的。而真的知道自己的实力么，掌握好自己的优缺，了解自己所想要的不？是很关键的也容易被环境带偏&lt;/p&gt;
&lt;h3 id=&#34;做决策客观了么&#34;&gt;做决策，客观了么？&lt;/h3&gt;
&lt;p&gt;心里学上 人们选择一个事情，不是这个事情真实客观，而是人们期望他是对的，想要他是对的。&lt;/p&gt;
&lt;p&gt;最后生活并没有银弹，养兵千日用兵一时。基本面做的好了，操作面做的再差胜算也大；基本面做的普通，也不要放弃，操作面上还有很多空间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽信书不如无书，理论很多，观点很多，说法很多，怎么去选择，怎么去用呢？&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>扩展性设计</title>
      <link>https://tomorrowthief.github.io/posts/extend-design/</link>
      <pubDate>Wed, 11 May 2022 10:38:36 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/extend-design/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前在公司内部做过「扩展性设计」的分享。后面重新整理形成博客形式记录自己的学习。&lt;/p&gt;
&lt;p&gt;由于作者长期从事Web前端领域的工作的原因，本文也是基于这些技术领域发出的一些关于应用软件方向上的扩展性总结&lt;/p&gt;
&lt;h2 id=&#34;什么是扩展性设计&#34;&gt;什么是扩展性设计&lt;/h2&gt;
&lt;p&gt;软件架构设计里比较关注的几个要素：&lt;code&gt;扩展性&lt;/code&gt;，&lt;code&gt;稳定性&lt;/code&gt;，&lt;code&gt;可维护性&lt;/code&gt;。很多领域里都会有这方面的考虑。比如：业务架构，产品架构，软件技术架构。那么具体怎么定义呢&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Extensibility is a software engineering and systems design principle where the implementation takes future growth into consideration&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展性是在考虑未来增长发展时所做的一些工程实践和系统设计原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引用自维基百科的定义&lt;/p&gt;
&lt;h2 id=&#34;基础理论&#34;&gt;基础理论&lt;/h2&gt;
&lt;p&gt;这里讨论的理论基础是比较原始的，类似于数学或物理中的定律定理。实践中是要结合具体场景通过组合这里理论，以及基于这些理论做些推导来形成最佳的设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到变化的东西&lt;/li&gt;
&lt;li&gt;solid原则&lt;/li&gt;
&lt;li&gt;分层明确&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常用形式&#34;&gt;常用形式&lt;/h2&gt;
&lt;h3 id=&#34;中间件&#34;&gt;中间件&lt;/h3&gt;
&lt;p&gt;中间件是一种实践比较成熟的形式了。基本的思想是根据一些约定拦截输入，做一些逻辑，或者修改挂载上下文，然后继续向下流。具体的形式上有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;洋葱模型中间件： &lt;code&gt;koa2&lt;/code&gt;， &lt;code&gt;redux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;管道化模型的中间件：&lt;code&gt;pipe&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中间件实践中要考虑的因素是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间件收集方式&lt;/li&gt;
&lt;li&gt;中间件之间的关系，顺序等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插件&#34;&gt;插件&lt;/h3&gt;
&lt;p&gt;这种形式也比较常见。类似于&lt;code&gt;微内核&lt;/code&gt; + &lt;code&gt;plugin/addon&lt;/code&gt; 模型。市面上也存在了很多基于此架构的工具或框架。此模式实践中要考虑的因素是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离性：暴露主应用的那些能力，防止插件的运行影响主应用逻辑&lt;/li&gt;
&lt;li&gt;性能：进程模型设计，是否独立进程运行&lt;/li&gt;
&lt;li&gt;生命周期：插件加载时机，插件执行时机&lt;/li&gt;
&lt;li&gt;插件之间管理：插件之间是否能互相调用，互相影响&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;插件机制思想很简单，重要的是各种实现细节，实践中有不同形式与细节。这里日后单独写一篇文章来分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;p&gt;读取配置文件，读取参数都是这种形式。是一种简单但实用的形式。不过多讨论&lt;/p&gt;
&lt;h2 id=&#34;案例分析&#34;&gt;案例分析&lt;/h2&gt;
&lt;h3 id=&#34;webpack中的扩展性设计&#34;&gt;webpack中的扩展性设计&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt; 是一个比较流行的打包工具。其功能的强大，生态的繁荣离不他的插件体系和loader体系。本身作为一个流程控制中心，很多功能都是分散在各个插件里来做的&lt;/p&gt;
&lt;h4 id=&#34;loader体系&#34;&gt;loader体系&lt;/h4&gt;
&lt;p&gt;针对特定的文件类型来做处理的，有点类似上一节提到的&lt;code&gt;管道化中间件模型&lt;/code&gt;。针对特定类型文件可以提供多个，按照顺序管道化的处理转换。&lt;/p&gt;
&lt;h4 id=&#34;插件体系&#34;&gt;插件体系&lt;/h4&gt;
&lt;p&gt;webpack 内部主要的两个概念是 &lt;code&gt;complier&lt;/code&gt;主要负责构建整体流程等，&lt;code&gt;compliton&lt;/code&gt;主要负责构建里的具体编译工作。这两者都是通过 &lt;code&gt;Tapable&lt;/code&gt; 库来完成内部生命周期暴露，&lt;code&gt;Tapable&lt;/code&gt; 大体上是一种 &lt;code&gt;sub-pub&lt;/code&gt; 模式的实现, 其核心概念 hook 可以与 event系统里的某个 event 等价。在同一个hook下可以绑定很多handler的注册，有点像AOP编程思想。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>深度思考</title>
      <link>https://tomorrowthief.github.io/posts/deep-thinking/</link>
      <pubDate>Mon, 18 Apr 2022 10:08:36 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/deep-thinking/</guid>
      <description>&lt;p&gt;深度思考的重要性就不多强调了，该如何做好呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何做好深度思考？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;多维度&#34;&gt;多维度&lt;/h2&gt;
&lt;p&gt;我这里说的多维度可以理解为&lt;code&gt;多视角&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;做一个技术分享，在听众的视角下如何的，主办方的视角如何，分享者的视角又如何，领导视角，同事视角如何……&lt;/p&gt;
&lt;h2 id=&#34;多层次&#34;&gt;多层次&lt;/h2&gt;
&lt;p&gt;一个事物是处于整体系统里的那一层，与其他层的依赖关系。都是可以考虑的&lt;/p&gt;
&lt;p&gt;比如日常技术问题处理，问题本身是如何的，处理及反馈流程是如何的，技术依赖的其他系统大概如何的……&lt;/p&gt;
&lt;h2 id=&#34;现象与本质&#34;&gt;现象与本质&lt;/h2&gt;
&lt;p&gt;有哲学基础的都会知道，事物的发展变化都会有表现与本质的区别。这一点有点像我们使用技术框架时，能掌握好框架的使用层以及底层原理，才能以正确的姿势使用。&lt;/p&gt;
&lt;p&gt;同样道理，思考问题的表现以及底层逻辑如何，才能做好深度思考。实际中可能会更加复杂：人的关系，系统的关系，技术本身的关系&lt;/p&gt;
&lt;h2 id=&#34;刻意练习&#34;&gt;刻意练习&lt;/h2&gt;
&lt;p&gt;所谓学而不思则茫，有了理论基础，加上一些&lt;code&gt;刻意练习&lt;/code&gt;，才能真正掌握。具体落地点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多总结&lt;/li&gt;
&lt;li&gt;多复盘&lt;/li&gt;
&lt;li&gt;多积累方法论&lt;/li&gt;
&lt;li&gt;多接触不同系统的案例&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>蛙泳学思</title>
      <link>https://tomorrowthief.github.io/posts/swim/</link>
      <pubDate>Fri, 15 Apr 2022 14:34:21 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/swim/</guid>
      <description>&lt;p&gt;最近开始学习蛙泳，其实很早之前下水练习过几次，但是没有系统的整理。最近开始了系统性的练习：看了些视频讲解，纠正了些错误，总算有些小进步。&lt;/p&gt;
&lt;p&gt;过程中发现了自己之前很多动作，模式，思考是不对的。但是纠正这些不对的点花费了很久时间。学习效率比较低。而纠正错误的技巧以及思路是一个通用的学习理论，对于工作，生活应该都适用。所以做了此快速学习新技能技巧的总结，或者称之为方法论也好。&lt;/p&gt;
&lt;h2 id=&#34;学习速度&#34;&gt;学习速度&lt;/h2&gt;
&lt;p&gt;掌握好正确的路径，学习资料，其余的就是练习了。理论与实践相辅相承。在实践中遇到问题，可能是理论没有吃透，可以多补充。比如不知道动作该怎么连贯（划手蹬腿结合）的时候，可以补充下理论。理论充足不等于实践也厉害，因为都有个人，环境的因素。&lt;/p&gt;
&lt;p&gt;所以 &lt;code&gt;理论和实践结合 互相补充&lt;/code&gt; 来提速&lt;/p&gt;
&lt;h2 id=&#34;基础比较关键&#34;&gt;基础比较关键&lt;/h2&gt;
&lt;p&gt;最重要的基础点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;划手&lt;/li&gt;
&lt;li&gt;蹬腿&lt;/li&gt;
&lt;li&gt;协调&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;切记欲速不达的道理： 我之前基础练习的不够好，蹬腿，划手导致在完整动作时漏洞百出，出了问题没有头绪，然后再回过头一点一点练习基础才能做好完整动作，这个过程就比较浪费时间了。
在看专业运动员每一个细节都特别好，大概就是基础比较扎实了吧。所以想要快速达到目标，不要忽视了基础。&lt;code&gt;稳扎稳打可能是速度最快的方式&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;好的老师&#34;&gt;好的老师&lt;/h2&gt;
&lt;p&gt;个人在实践中总是会有很多点会偏离最优，有些思想也会偏离。有的时候会卡在某个环节出不来，这个时候如果自己有良好的资料可以参考，最好了。
比如我在呼气练习的时候，水下一直是哈气的动作，水上就不能很好的吸气了，知道看到有个解说提醒说水下吐气，才知道，这个环节练习错了。这个哈气矫正为吐气的过程是看了讲解。但是假如有个好教师帮忙点一二，可以快速解围解困惑的。&lt;/p&gt;
&lt;p&gt;类似的工作中也比较强调有好的导师，好的领导的重要性，所谓读万卷书不如行万里路，不过阅人无数，不如良师指点。
所以如何发现好老师？正规的学习指南，学习资料是大家当前最合适的，有真人最好了。&lt;/p&gt;
&lt;p&gt;最后发现总结的都是些大道理，这些大道理大家应该都懂，但是怎么与实际结合并帮助实践是比较关键的。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文通过个人蛙泳学习过程中遇到的问题做了些反思，总结了一些快速学习技能的通用技巧方法论。并强调这些大道理如何与实际结合的技巧才是关键。希望对做其他事情有帮助，也不枉这次辛苦练习了。最后学习的过程是没有银弹的，前进吧少年&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>文章搬运开始啦</title>
      <link>https://tomorrowthief.github.io/posts/kaishila/</link>
      <pubDate>Thu, 14 Apr 2022 20:21:59 +0800</pubDate>
      
      <guid>https://tomorrowthief.github.io/posts/kaishila/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;p&gt;最近比较空闲，在写作东西的时候发现一个不错的主题。刚好自己除了一些公共账号外，还没自己的博客，遂搭建之。&lt;/p&gt;
&lt;p&gt;主题：基于Hugo，详细可以见网站底部。托管于 &lt;code&gt;GitHub Pages&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;博客内容&#34;&gt;博客内容&lt;/h2&gt;
&lt;p&gt;主要是搬移之前写过的一些东西，同时做了一些格式化处理。未来新写的东西应该会首先发到这里了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;菩提本无树，明镜亦非台，本来无一物，何处惹尘埃&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
