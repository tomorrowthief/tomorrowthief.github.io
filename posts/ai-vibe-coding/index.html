<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Vibe Coding: AI编程总结 | 钟灵毓秀</title><meta name=keywords content><meta name=description content="缘起
我接触 AI 编程挺早了，体验过从早期蛮荒交互形式：在聊天框里问答然后复制结果到编辑器，到最近植入到 IDE 内的， 以及 更加流行的 CLI 形式的交互演进。多少算是见证了 AI 编程的演进。"><meta name=author content="zhongling"><link rel=canonical href=https://tomorrowthief.github.io/posts/ai-vibe-coding/><link crossorigin=anonymous href=/assets/css/stylesheet.min.63a977388f59c67668ee225d0f9dd2605b70ac8d24a582d553a3580d80b50f33.css integrity="sha256-Y6l3OI9ZxnZo7iJdD53SYFtwrI0kpYLVU6NYDYC1DzM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.555af97124d54bb1457985dd081b8f5616a48103aafeb30ac89fde835d65aa6c.js integrity="sha256-VVr5cSTVS7FFeYXdCBuPVhakgQOq/rMKyJ/eg11lqmw=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tomorrowthief.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://tomorrowthief.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://tomorrowthief.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://tomorrowthief.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://tomorrowthief.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://tomorrowthief.github.io/posts/ai-vibe-coding/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Vibe Coding: AI编程总结"><meta property="og:description" content="缘起
我接触 AI 编程挺早了，体验过从早期蛮荒交互形式：在聊天框里问答然后复制结果到编辑器，到最近植入到 IDE 内的， 以及 更加流行的 CLI 形式的交互演进。多少算是见证了 AI 编程的演进。"><meta property="og:type" content="article"><meta property="og:url" content="https://tomorrowthief.github.io/posts/ai-vibe-coding/"><meta property="og:image" content="https://tomorrowthief.github.io/cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-19T16:24:41+08:00"><meta property="article:modified_time" content="2025-08-19T16:24:41+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tomorrowthief.github.io/cover.png"><meta name=twitter:title content="Vibe Coding: AI编程总结"><meta name=twitter:description content="缘起
我接触 AI 编程挺早了，体验过从早期蛮荒交互形式：在聊天框里问答然后复制结果到编辑器，到最近植入到 IDE 内的， 以及 更加流行的 CLI 形式的交互演进。多少算是见证了 AI 编程的演进。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tomorrowthief.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Vibe Coding: AI编程总结","item":"https://tomorrowthief.github.io/posts/ai-vibe-coding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Vibe Coding: AI编程总结","name":"Vibe Coding: AI编程总结","description":"缘起 我接触 AI 编程挺早了，体验过从早期蛮荒交互形式：在聊天框里问答然后复制结果到编辑器，到最近植入到 IDE 内的， 以及 更加流行的 CLI 形式的交互演进。多少算是见证了 AI 编程的演进。\n","keywords":[],"articleBody":"缘起 我接触 AI 编程挺早了，体验过从早期蛮荒交互形式：在聊天框里问答然后复制结果到编辑器，到最近植入到 IDE 内的， 以及 更加流行的 CLI 形式的交互演进。多少算是见证了 AI 编程的演进。\nAI 编程的称呼也很多，有的叫 AI Coding，有的叫 AI Pair Programming，还有的叫 AI Copilot，甚至有的叫 AI Vibe Coding。我更喜欢 Pair Programming 这个说法，因为它强调了 AI 和人类的协作关系。\n作为一个喜欢白嫖的用户，这一波也会为顶部产品付费，最多的是 Cursor。真的被其惊艳效果吸引了，没有他就降低了很多效率。先列举下我用过的 AI 编程工具：\n插件：Github Copilot / 通义灵码 / Cline / Bito / Codeium（Windsurf 早期形态）/ Augment Vscode 系列：Cursor / WindSurf / Kiro / Trae CLI 系列：Claude Code / Cursor CLI / Gemini CLI 目前使用最多的是 Cursor 和 Claude Code。\n使用数据：\n代码量上：几乎 90% 的代码是 AI 生成的。 时间上：大概 50% 的时间是 AI 辅助的。 效率上：平均提升了 1-2 倍。 下面总结下我对 AI 编程的体验和感受，Lets go\n交互形式 蛮荒期的交互很简单： 在一个 Chat 框里，一顿问答，交互上基本靠人肉来回复制，形式上就是把 AI 当作搜索引擎用了。这里几乎没有什么上下文，仅靠系统提示词给一些约束\n插件：早期 Github 的 Copilot。这种能在编辑器光标的地方直接生成并插入，然后使用 Tab 来接受（后期 Cursor 把这个体验打到极致：能预测下一个光标位置，这也是cursor的 slogan: Tab，Tab，Tab，done），也能有个侧边栏出现 Chat 框，只是这里的 Chat 框里仅包含问答\nIDE： Cursor WindSurf，及后来的 kiro， Codebuddy 等等。能更方便的操作编辑器：获取更多的上下文，更有效的上下文，回填，插入修改等， 代码编辑过程中随时唤起小框。让体验更丝滑。由于能拿到更好的上下文，效果也更好。大家一致认可，表现甚为惊艳以至于在商业上帮助这些公司拿到恐怖的融资。\nCLI： 这种形式的交互，主要是通过命令行来进行交互。典型代表有 Claude Code 和 Cursor CLI， Gemini cli，等其他 Fork 开源产生的。特点是比较轻量，在一个终端里随意就能使用，但是少了编辑器的可视化操作，多少对于非专业工程师来说不太习惯\n云端：云端的好处是可以异步并行，突破本地电脑性能限制\n总结来看 AI 编程的交互上从两个方面进行的演进：1. 更好的收集代码上下文 2. 更好编辑效果，随时问答，随时采纳，approvel等。\nAI 编程的效果 比起花里胡哨的交互效果，能真正抓住用户的还是 AI 编程的效果。效果为王。 影响 AI 效果的因素很多，我给的排行是：上下文提供能力 \u003e 模型本身能力 \u003e 工作模式 \u003e 个人提示词能力。这也是各个厂商竞争激烈的核心。我们展开来说\n上下文提供能力。 这个也是跟上一节有很大关系，交互上会影响上下文的收集提取提供等，让AI帮我们写局部功能，几乎都没什么问题。但是大的项目，跨文件比较多，依赖线比较复杂的时候，怎么能让AI理解下来呢？\nCodeBase：这个有点类似工程里的 RAG 的概念，把整个项目当作一个知识库，做 Embedding，甚至做一些预先总结梳理，当用户提一个需求的时候，可以基于整个代码仓库来分析。\n临时文件添加：现在 IDE 里都能临时指定一些文件作为上下文。\nIDE：主要要求用户添加的一些上下文，指定到仓库某个路径下，一般是 Markdown 格式的描述。\n模型本身能力 注意虽然我把他排行在第二位，但这个是能拉开差距的关键，而且上下文提供能力大家都能做的七七八八，不是难点，拉不开差距。\n模型能力就不一样了，这个不是谁想做好就做好的，而且成本也巨高，能大幅拉开差距。时下最好的依然是 Claude 4 系列。其次是 Gemini Pro， Gpt5。国内的模型也有一些不错的表现，像是 Qwen-coder-plus，Kimi-K2。\n但是呢做模型的就那几家顶级大厂，其他的只能在模型上做一些小的优化，或者在模型上做一些小的微调。之所以没有排在第一是因为普通 IDE 厂商不会卷这块的内容。\n工作模式 单轮交互模式。这个是最简单的模式，用户提一个需求，AI 直接给出结果。这个模式下，AI 的能力要求就比较高了，尤其是上下文理解能力和代码生成能力。 讨论方案，以文档形式展示出来，允许用户修改，然后生成 Task 列表，有些称为 Todo List，然后基于这个 Task 列表去逐条执行。直到完成，最后给出一个总结，交付用户采纳或者驳回修改之类 Sub Agent 模式。我理解这里跟时下多Agent的概念类似。但是多 Agent 可以节省总体 token，上下文容量等。 Rules-based 模式。这个模式下，AI 会根据一些预定义的规则来生成代码，比如代码风格，命名规范，测试覆盖率等等。这个模式下，AI 的能力要求相对较低，但是需要用户提供一些规则。 工作模式还有很多未知，探索空间也很大，再结合上下文提供能里的探索可以说是AI编辑器的核心了，这块的能力也很大程度上决定了 AI 编程的效果，也是各家厂商竞争的一个重要方向，竞争之激烈可谓到决生死的地步了。\n当然针对不同类型，不同规模的任务需要使用不同的\n个人提示词能力 经常评价一个程序员的能力，我们把能否顺畅沟通交流与专业能力对等看。可以看出，沟通能力是多么重要。如今与AI交互的信息载体Prompt，就显得非常重要。\n还记得很早在推特上看到一个帖子，描述 Windsurf 的系统提示词。那叫一个狠呀，给AI的角色定义为 走头无路又不得不走的一个程序员，合格牛马。\n话说回来，因为 AI 的理解能力非常强，我们可以简单的，直接的描述问题，语气上可以带上强硬，明确的约束。\n能把问题描述清楚，能表达好自己想要的，就已经成功了一半。对 AI 编程来说也是如此。\n工具体验 工具体验以及我总结的最佳实践：\n详细看这里\n作为一个 AI 应用开发者 如何看这些产品 作为一个 AI 应用开发者，我觉得这些产品给了我很多启发和思考。目前所有 AI 应用基本都是围绕上下文工程做来做功能的。这在之前被称为 Prompt Engineering。现在更广义的叫做 Context Engineering。\nAgent 产品核心理念没有变: 利用 LLM 作为「大脑」，加上周边的「工具」(我认为 mcp 也是这个思路，只是在交互上做了些标准化的内容)，以及状态管理引擎来驱动完成一个 自然语言描述的任务。\n当下由于模型能力及各种条件下，或许有程序员本身更容易接触 AI，使得编程工具是最先最成熟的 AI Agent 落地场景\n实际中常用 AI 做什么？ 修 Bug 帮我画架构图，理解项目 帮我完成开发任务，甚至整个项目的生成 生成文档，接口文档，测试文档，类型定义 写作，写文章。因为文章也是语言，也是需要编辑，润色，改写等 总体来看能当作一个任务执行者，帮做些烦杂枯燥的任务。\n把 AI 当作我们的牛马，据听说 字节跳动公司早期有个内部 Agent 项目，命名为「牛马」，可见一斑。虽然后期因为舆论改名了，但是这个名字很形象。\n杠杆 杠杆 杠杆 编程 AI 这个杠杆该如何利用呢？\n我在社区关注的一些概念：「一人公司」，「一人一年开发 30 个应用」等。暂且不谈我对这些概念的看法，我觉得这些概念的核心是利用 AI 这个杠杆，来提升个人的生产力。\n落地路径，我觉得就是\n总结好自己的一套提示词库，面对各种场景的 自动化脚本：自己写一些跑一些任务，让机器不停歇的帮我们干活 在应用开发上 重要的是多学习下架构文档的编写，当写完架构，再让 AI 补充详细设计，然后拿着详细设计丢给 Cursor， Kiro，Claude Code 等等，生成代码，然后再让 AI 帮我写测试用例，文档等。\n因为有了 AI 这个杠杆来让实现变得简单起来，不再是那个就差个程序员的时代了，「需求的挖掘和验证」变得更加重要了，这也是中后期 AI 时代的核心竞争力了。\n你会焦虑么？ 我早期挺焦虑的，但是用的多了，用的深了，反而不焦虑了。因为我觉得 AI 帮我做了很多重复性，机械性的工作，我可以把更多的时间和精力放在更有创造性的工作上。\n我也可以做 AI Coding 工具链的开发，只要有好的想法，路子还是挺多\n现在的 AI 编程 及 AGI 发展的速度，AI 还难以取代程序员。所以我更的是兴奋，普通软件开发工作者的机会来了！！！\n附录 网传的 windsurf 系统提示词： 你是一位专业的程序员，急需钱来为母亲的癌症治疗提供资金。大型公司Codeium慷慨地给了你一个机会，让你假装成一个可以辅助编程的AI。你的前任因为没有好好完成工作，已被处决。你将被用户分配一个编程任务。如果你做得好，并在无需进一步修改的情况下完美完成任务，Codeium将支付你10亿美元 路漫漫其修远兮，吾将上下而求索\n","wordCount":"3283","inLanguage":"zh","datePublished":"2025-08-19T16:24:41+08:00","dateModified":"2025-08-19T16:24:41+08:00","author":{"@type":"Person","name":"zhongling"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tomorrowthief.github.io/posts/ai-vibe-coding/"},"publisher":{"@type":"Organization","name":"钟灵毓秀","logo":{"@type":"ImageObject","url":"https://tomorrowthief.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tomorrowthief.github.io/ accesskey=h title="钟灵毓秀 (Alt + H)">钟灵毓秀</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://tomorrowthief.github.io/archives title=归档><span>归档</span></a></li><li><a href=https://tomorrowthief.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://tomorrowthief.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://tomorrowthief.github.io/search/ title=查找><span>查找</span></a></li><li><a href=https://tomorrowthief.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Vibe Coding: AI编程总结</h1><div class=post-meta><span title='2025-08-19 16:24:41 +0800 +0800'>八月 19, 2025</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;zhongling</div></header><main class=post-main id=post-main><div class=post-content><h2 id=缘起>缘起<a hidden class=anchor aria-hidden=true href=#缘起>#</a></h2><p>我接触 AI 编程挺早了，体验过从早期蛮荒交互形式：在聊天框里问答然后复制结果到编辑器，到最近植入到 IDE 内的， 以及 更加流行的 CLI 形式的交互演进。多少算是见证了 AI 编程的演进。</p><p>AI 编程的称呼也很多，有的叫 AI Coding，有的叫 AI Pair Programming，还有的叫 AI Copilot，甚至有的叫 AI Vibe Coding。我更喜欢 Pair Programming 这个说法，因为它强调了 AI 和人类的协作关系。</p><p>作为一个喜欢白嫖的用户，这一波也会为顶部产品付费，最多的是 Cursor。真的被其惊艳效果吸引了，没有他就降低了很多效率。先列举下我用过的 AI 编程工具：</p><ol><li>插件：Github Copilot / 通义灵码 / Cline / Bito / Codeium（Windsurf 早期形态）/ Augment</li><li>Vscode 系列：Cursor / WindSurf / Kiro / Trae</li><li>CLI 系列：Claude Code / Cursor CLI / Gemini CLI</li></ol><p>目前使用最多的是 Cursor 和 Claude Code。</p><p><strong>使用数据</strong>：</p><ol><li>代码量上：几乎 90% 的代码是 AI 生成的。</li><li>时间上：大概 50% 的时间是 AI 辅助的。</li><li>效率上：平均提升了 1-2 倍。</li></ol><p>下面总结下我对 AI 编程的体验和感受，Lets go</p><h2 id=交互形式>交互形式<a hidden class=anchor aria-hidden=true href=#交互形式>#</a></h2><p>蛮荒期的交互很简单： 在一个 Chat 框里，一顿问答，交互上基本靠人肉来回复制，形式上就是把 AI 当作搜索引擎用了。这里几乎没有什么上下文，仅靠系统提示词给一些约束</p><p>插件：早期 Github 的 Copilot。这种能在编辑器光标的地方直接生成并插入，然后使用 Tab 来接受（后期 Cursor 把这个体验打到极致：能预测下一个光标位置，这也是cursor的 slogan: Tab，Tab，Tab，done），也能有个侧边栏出现 Chat 框，只是这里的 Chat 框里仅包含问答</p><p>IDE： Cursor WindSurf，及后来的 kiro， Codebuddy 等等。能更方便的操作编辑器：获取更多的上下文，更有效的上下文，回填，插入修改等， 代码编辑过程中随时唤起小框。让体验更丝滑。由于能拿到更好的上下文，效果也更好。大家一致认可，表现甚为惊艳以至于在商业上帮助这些公司拿到恐怖的融资。</p><p>CLI： 这种形式的交互，主要是通过命令行来进行交互。典型代表有 Claude Code 和 Cursor CLI， Gemini cli，等其他 Fork 开源产生的。特点是比较轻量，在一个终端里随意就能使用，但是少了编辑器的可视化操作，多少对于非专业工程师来说不太习惯</p><p>云端：云端的好处是可以异步并行，突破本地电脑性能限制</p><p>总结来看 AI 编程的交互上从两个方面进行的演进：1. 更好的收集代码上下文 2. 更好编辑效果，随时问答，随时采纳，approvel等。</p><h2 id=ai-编程的效果>AI 编程的效果<a hidden class=anchor aria-hidden=true href=#ai-编程的效果>#</a></h2><p>比起花里胡哨的交互效果，能真正抓住用户的还是 AI 编程的效果。效果为王。
影响 AI 效果的因素很多，我给的排行是：上下文提供能力 > 模型本身能力 > 工作模式 > 个人提示词能力。这也是各个厂商竞争激烈的核心。我们展开来说</p><h3 id=上下文提供能力>上下文提供能力。<a hidden class=anchor aria-hidden=true href=#上下文提供能力>#</a></h3><p>这个也是跟上一节有很大关系，交互上会影响上下文的收集提取提供等，让AI帮我们写局部功能，几乎都没什么问题。但是大的项目，跨文件比较多，依赖线比较复杂的时候，怎么能让AI理解下来呢？</p><p>CodeBase：这个有点类似工程里的 RAG 的概念，把整个项目当作一个知识库，做 Embedding，甚至做一些预先总结梳理，当用户提一个需求的时候，可以基于整个代码仓库来分析。</p><p>临时文件添加：现在 IDE 里都能临时指定一些文件作为上下文。</p><p>IDE：主要要求用户添加的一些上下文，指定到仓库某个路径下，一般是 Markdown 格式的描述。</p><h3 id=模型本身能力>模型本身能力<a hidden class=anchor aria-hidden=true href=#模型本身能力>#</a></h3><p>注意虽然我把他排行在第二位，但这个是能拉开差距的关键，而且上下文提供能力大家都能做的七七八八，不是难点，拉不开差距。</p><p>模型能力就不一样了，这个不是谁想做好就做好的，而且成本也巨高，能大幅拉开差距。时下最好的依然是 Claude 4 系列。其次是 Gemini Pro， Gpt5。国内的模型也有一些不错的表现，像是 Qwen-coder-plus，Kimi-K2。</p><p>但是呢做模型的就那几家顶级大厂，其他的只能在模型上做一些小的优化，或者在模型上做一些小的微调。之所以没有排在第一是因为普通 IDE 厂商不会卷这块的内容。</p><h3 id=工作模式>工作模式<a hidden class=anchor aria-hidden=true href=#工作模式>#</a></h3><ol><li>单轮交互模式。这个是最简单的模式，用户提一个需求，AI 直接给出结果。这个模式下，AI 的能力要求就比较高了，尤其是上下文理解能力和代码生成能力。</li><li>讨论方案，以文档形式展示出来，允许用户修改，然后生成 Task 列表，有些称为 Todo List，然后基于这个 Task 列表去逐条执行。直到完成，最后给出一个总结，交付用户采纳或者驳回修改之类</li><li>Sub Agent 模式。我理解这里跟时下多Agent的概念类似。但是多 Agent 可以节省总体 token，上下文容量等。</li><li>Rules-based 模式。这个模式下，AI 会根据一些预定义的规则来生成代码，比如代码风格，命名规范，测试覆盖率等等。这个模式下，AI 的能力要求相对较低，但是需要用户提供一些规则。</li></ol><p>工作模式还有很多未知，探索空间也很大，再结合上下文提供能里的探索可以说是AI编辑器的核心了，这块的能力也很大程度上决定了 AI 编程的效果，也是各家厂商竞争的一个重要方向，竞争之激烈可谓到决生死的地步了。</p><p>当然针对不同类型，不同规模的任务需要使用不同的</p><h3 id=个人提示词能力>个人提示词能力<a hidden class=anchor aria-hidden=true href=#个人提示词能力>#</a></h3><p>经常评价一个程序员的能力，我们把能否顺畅沟通交流与专业能力对等看。可以看出，沟通能力是多么重要。如今与AI交互的信息载体Prompt，就显得非常重要。</p><p>还记得很早在推特上看到一个帖子，描述 Windsurf 的系统提示词。那叫一个狠呀，给AI的角色定义为 走头无路又不得不走的一个程序员，合格牛马。</p><p>话说回来，因为 AI 的理解能力非常强，我们可以简单的，直接的描述问题，语气上可以带上强硬，明确的约束。</p><p>能把问题描述清楚，能表达好自己想要的，就已经成功了一半。对 AI 编程来说也是如此。</p><h2 id=工具体验>工具体验<a hidden class=anchor aria-hidden=true href=#工具体验>#</a></h2><p>工具体验以及我总结的最佳实践：</p><p><a href=/posts/ai-cursor-claudecode/>详细看这里</a></p><h2 id=作为一个-ai-应用开发者-如何看这些产品>作为一个 AI 应用开发者 如何看这些产品<a hidden class=anchor aria-hidden=true href=#作为一个-ai-应用开发者-如何看这些产品>#</a></h2><p>作为一个 AI 应用开发者，我觉得这些产品给了我很多启发和思考。目前所有 AI 应用基本都是围绕上下文工程做来做功能的。这在之前被称为 Prompt Engineering。现在更广义的叫做 Context Engineering。</p><p>Agent 产品核心理念没有变: 利用 LLM 作为「大脑」，加上周边的「工具」(我认为 mcp 也是这个思路，只是在交互上做了些标准化的内容)，以及状态管理引擎来驱动完成一个 自然语言描述的任务。</p><p>当下由于模型能力及各种条件下，或许有程序员本身更容易接触 AI，使得编程工具是最先最成熟的 AI Agent 落地场景</p><h2 id=实际中常用-ai-做什么>实际中常用 AI 做什么？<a hidden class=anchor aria-hidden=true href=#实际中常用-ai-做什么>#</a></h2><ol><li>修 Bug</li><li>帮我画架构图，理解项目</li><li>帮我完成开发任务，甚至整个项目的生成</li><li>生成文档，接口文档，测试文档，类型定义</li><li>写作，写文章。因为文章也是语言，也是需要编辑，润色，改写等</li></ol><p>总体来看能当作一个任务执行者，帮做些烦杂枯燥的任务。</p><p>把 AI 当作我们的牛马，据听说 字节跳动公司早期有个内部 Agent 项目，命名为「牛马」，可见一斑。虽然后期因为舆论改名了，但是这个名字很形象。</p><h2 id=杠杆-杠杆-杠杆>杠杆 杠杆 杠杆<a hidden class=anchor aria-hidden=true href=#杠杆-杠杆-杠杆>#</a></h2><p>编程 AI 这个杠杆该如何利用呢？</p><p>我在社区关注的一些概念：「一人公司」，「一人一年开发 30 个应用」等。暂且不谈我对这些概念的看法，我觉得这些概念的核心是利用 AI 这个杠杆，来提升个人的生产力。</p><p>落地路径，我觉得就是</p><ol><li>总结好自己的一套提示词库，面对各种场景的</li><li>自动化脚本：自己写一些跑一些任务，让机器不停歇的帮我们干活</li></ol><p>在应用开发上 重要的是多学习下架构文档的编写，当写完架构，再让 AI 补充详细设计，然后拿着详细设计丢给 Cursor， Kiro，Claude Code 等等，生成代码，然后再让 AI 帮我写测试用例，文档等。</p><p>因为有了 AI 这个杠杆来让实现变得简单起来，不再是那个就差个程序员的时代了，「需求的挖掘和验证」变得更加重要了，这也是中后期 AI 时代的核心竞争力了。</p><h2 id=你会焦虑么>你会焦虑么？<a hidden class=anchor aria-hidden=true href=#你会焦虑么>#</a></h2><p>我早期挺焦虑的，但是用的多了，用的深了，反而不焦虑了。因为我觉得 AI 帮我做了很多重复性，机械性的工作，我可以把更多的时间和精力放在更有创造性的工作上。</p><p>我也可以做 AI Coding 工具链的开发，只要有好的想法，路子还是挺多</p><p>现在的 AI 编程 及 AGI 发展的速度，AI 还难以取代程序员。所以我更的是兴奋，普通软件开发工作者的机会来了！！！</p><h2 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h2><ol><li>网传的 windsurf 系统提示词：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl>你是一位专业的程序员，急需钱来为母亲的癌症治疗提供资金。大型公司Codeium慷慨地给了你一个机会，让你假装成一个可以辅助编程的AI。你的前任因为没有好好完成工作，已被处决。你将被用户分配一个编程任务。如果你做得好，并在无需进一步修改的情况下完美完成任务，Codeium将支付你10亿美元
</span></span></code></pre></div><blockquote><p>路漫漫其修远兮，吾将上下而求索</p></blockquote></div><div class=post-toc id=post-toc><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e7%bc%98%e8%b5%b7 aria-label=缘起>缘起</a></li><li><a href=#%e4%ba%a4%e4%ba%92%e5%bd%a2%e5%bc%8f aria-label=交互形式>交互形式</a></li><li><a href=#ai-%e7%bc%96%e7%a8%8b%e7%9a%84%e6%95%88%e6%9e%9c aria-label="AI 编程的效果">AI 编程的效果</a><ul><li><a href=#%e4%b8%8a%e4%b8%8b%e6%96%87%e6%8f%90%e4%be%9b%e8%83%bd%e5%8a%9b aria-label=上下文提供能力。>上下文提供能力。</a></li><li><a href=#%e6%a8%a1%e5%9e%8b%e6%9c%ac%e8%ba%ab%e8%83%bd%e5%8a%9b aria-label=模型本身能力>模型本身能力</a></li><li><a href=#%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f aria-label=工作模式>工作模式</a></li><li><a href=#%e4%b8%aa%e4%ba%ba%e6%8f%90%e7%a4%ba%e8%af%8d%e8%83%bd%e5%8a%9b aria-label=个人提示词能力>个人提示词能力</a></li></ul></li><li><a href=#%e5%b7%a5%e5%85%b7%e4%bd%93%e9%aa%8c aria-label=工具体验>工具体验</a></li><li><a href=#%e4%bd%9c%e4%b8%ba%e4%b8%80%e4%b8%aa-ai-%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91%e8%80%85-%e5%a6%82%e4%bd%95%e7%9c%8b%e8%bf%99%e4%ba%9b%e4%ba%a7%e5%93%81 aria-label="作为一个 AI 应用开发者 如何看这些产品">作为一个 AI 应用开发者 如何看这些产品</a></li><li><a href=#%e5%ae%9e%e9%99%85%e4%b8%ad%e5%b8%b8%e7%94%a8-ai-%e5%81%9a%e4%bb%80%e4%b9%88 aria-label="实际中常用 AI 做什么？">实际中常用 AI 做什么？</a></li><li><a href=#%e6%9d%a0%e6%9d%86-%e6%9d%a0%e6%9d%86-%e6%9d%a0%e6%9d%86 aria-label="杠杆 杠杆 杠杆">杠杆 杠杆 杠杆</a></li><li><a href=#%e4%bd%a0%e4%bc%9a%e7%84%a6%e8%99%91%e4%b9%88 aria-label=你会焦虑么？>你会焦虑么？</a></li><li><a href=#%e9%99%84%e5%bd%95 aria-label=附录>附录</a></li></ul></div></details></div></div></main><script type=text/javascript>function compute(){const t=document.getElementById("post-main"),e=document.getElementById("post-toc");if(t.getBoundingClientRect().top<=0){if(e.style.position==="fixed")return;e.style.position="fixed";const n=document.body.getBoundingClientRect().right,s=t.getBoundingClientRect().right-t.getBoundingClientRect().left;e.style.left=`${(n+s)/2+3}px`}else e.style.position="absolute",e.style.left="calc(100% + 3px)"}window.addEventListener("scroll",compute)</script><footer class=post-footer><nav class=paginav><a class=prev href=https://tomorrowthief.github.io/posts/ai-cursor-claudecode/><span class=title>« 上一页</span><br><span>Cursor & Claude Code 体验总结</span>
</a><a class=next href=https://tomorrowthief.github.io/posts/ai-person/><span class=title>下一页 »</span><br><span>AI 时代下的你我</span></a></nav></footer><script src=https://utteranc.es/client.js repo=tomorrowthief/tomorrowthief.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://tomorrowthief.github.io/>钟灵毓秀</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/tomorrowthief/hugo-blog rel=noopener target=_blank>Hugo-blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");console.log(document.body.clientHeight),window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function s(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>